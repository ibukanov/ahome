#!/bin/sh

# shellcheck shell=dash
# shellcheck enable=all
# shellcheck disable=SC2249,SC2034

set -u -e
set -o noglob

# shellcheck source=./utils.sh
. "${0%/*}/utils.sh"

# shellcheck source=./container-kit.sh
. "${0%/*}/container-kit.sh"

valid_primary_host_names="rhea mimas"
valid_primary_host_names="$valid_primary_host_names r2.mir2.org"
valid_container_host_names="test-lms"
valid_host_names="$valid_primary_host_names $valid_container_host_names"
valid_host_names="$valid_host_names dev-igor"

readonly valid_primary_host_names
readonly valid_container_host_names
readonly valid_host_names

get_host_options() {

  zram_size=
  zram_algorithm=
  zram_writeback=
  zswap_persent=
  with_hibernation=
  custom_user_watches_count=
  with_disabled_selinux=
  with_disabled_firewalld=
  with_firewalld=
  with_persistent_journald=

  with_latex=
  with_common_packages=
  with_common_development_tools=
  with_include_rpmfusion=
  with_vm_tools=

  # Main user - must be when needed
  unset main_user
  with_gui_container_role=

  with_test_lms_container=

  with_dev_container=

  with_firejail_desktop_rules=

  with_custom_sshd=
  with_setuidless_sshd=
  with_remote_ssh_unlock=

  with_nginx=
  with_php_fpm=
  unset php_version
  tormed_host=
  with_game_access=

  with_user_sandboxes=

  lms_archive_time=
  lms_archive_root=

  with_stub_resolv_conf=
  with_forced_networkd=
  with_encrypted_dns=
  with_encrypted_dns_forced=
  with_mdns=

  webserver_certificate_domains=

  readonly dev_vz_network_prefix="192.168.97"

  with_disabled_turbo_boost=

  case "${NAME}" in
  r2.mir2.org )
    lms_archive_time=01:40:00
    lms_archive_root=/srv/backup/lms-hosts
    zram_size=$((8*1024))
    zram_algorithm=lz4
    with_stub_resolv_conf=1
    with_forced_networkd=1
    with_custom_sshd=1
    #with_remote_ssh_unlock=1
    with_nginx=1
    enable_tormed media.mir2.org
    with_test_lms_container=1
    with_user_sandboxes=1
    with_firewalld=1
    with_common_packages=1
    ;;

  mimas )
    main_user=igor
    with_common_packages=1
    with_common_development_tools=1
    with_vm_tools=1
    with_latex=1
    zram_size=$((16*1024))
    zram_algorithm=lz4
    with_disabled_turbo_boost=1

    #with_stub_resolv_conf=1
    #with_encrypted_dns=1
    with_mdns=1

    #custom_user_watches_count="$((768*1025))"
    with_firejail_desktop_rules=1
    with_firewalld=1
    ;;

  rhea )
    main_user=igor
    with_common_packages=1
    with_latex=1
    #with_disabled_selinux=1

    with_hibernation=1

    # There is also the real swap device on the machine, so use the fastest
    # compression algorithm here and do not use too much space.
    #
    #zram_size=$((24 * 1024))
    #zram_algorithm=lz4

    # TODO: Consider using writeback device for zram when it will be
    # supported by Fedora
    #zram_writeback=/dev/disk/by-label/zram-writeback

    # Prefer zswap as that deals with uncompressible data comming from images
    # in browser caches or memory compression in VMs.
    # zswap_persent=15

    with_disabled_turbo_boost=1

    #with_stub_resolv_conf=1
    #with_encrypted_dns=1

    custom_user_watches_count="$((768*1025))"
    with_firejail_desktop_rules=1
    ;;

  dev-igor )
    zswap_persent=15
    #zram_size=$((8*1024))
    #zram_algorithm=lz4
    with_common_packages=1
    custom_user_watches_count=524288
    ;;

  * )
    err "unknown '${NAME}'"
    ;;
  esac
}

determine_os() {
  kind_fedora=
  kind_ubuntu=
  kind_debian=

  # VM runs under Qubes OS
  under_qubes=

  local os_kind
  os_kind=
  if test -f /etc/os-release; then
    local line
    {
      while IFS='' read -r line; do
        local s
        s="${line#ID=}"
        if test "x${s}" != "x${line}"; then
          os_kind="${s}"
          break;
        fi
      done
    } < /etc/os-release
  fi

  case "${os_kind}" in
  debian ) kind_debian=1 ;;
  fedora ) kind_fedora=1 ;;
  ubuntu ) kind_ubuntu=1 ;;
  * ) err "Do not know how to determine OS, os_kind='${os_kind}'" ;;
  esac
  if test -d /etc/qubes; then
    under_qubes=1
  fi
  readonly under_qubes

  if test -n "${kind_fedora}"; then
    fedora_release="$(rpm -E %fedora)"
  fi
}

log_indent_level=0

log() {
  local indent='' i
  i=0
  while test "${i}" -lt "${log_indent_level}"; do
    indent="${indent}  "
    : $((i+=1))
  done
  printf '%s%s\n' "${indent}" "$*" 1>&2
}

inc_log_level() {
  : $((log_indent_level+=1))
}

dec_log_level() {
  test 1 -le "${log_indent_level}" || \
      err "dec_log_level without inc_log_level"
  : $((log_indent_level-=1))
}

is_valid_host_name() {
  local name names i
  name="$1"
  names="${2-}"
  test "${names}" || names="${valid_host_names}"

  for i in ${names}; do
    if test "x${i}" = "x${name}"; then
      return 0
    fi
  done
  return 1;
}

# ensure that a config file $1 contains $2 at its end between marker comments
ensure_config_file_tail_section() {
  local path section
  path="$1"
  section="$2"

  test -f "${path}" || err "${path} does not exist. A section cannot be added."

  local section_start_mark section_end_mark
  section_start_mark="#-# (tliset start)"
  section_end_mark="#-# (tliset end)"

  local lineno inside_section found_section right_after_end_mark
  local old_section

  file_update=
  lines=
  inside_section=
  found_section=
  right_after_end_mark=
  while :; do
    local line
    line=
    if ! IFS= read -r line; then
      if test "${line}" && test "${lines}"; then
        err "${path} ends with line without \\n"
      fi
      if test "${right_after_end_mark}"; then
        if test "${old_section}" = "${section}"; then
          return 0
        fi
      fi
      break
    fi
    right_after_end_mark=
    if test -z "${inside_section}"; then
      if test "${found_section}"; then
        err "${path} contains lines after the tail custom section"
      fi
      if test "${line}" = "${section_end_mark}"; then
        err "${path} contains section end marker without the start marker"
      fi
      if test "${line}" = "${section_start_mark}"; then
        if test "${found_section}"; then
          err "${path} contains duplicated section"
        fi
        found_section=1
        inside_section=1
        old_section=
      else
        lines="${lines}${line}${NL}"
      fi
    else
      if test "${line}" = "${section_start_mark}"; then
        err "${path} contains duplicated section start markers"
      fi
      if test "${line}" = "${section_end_mark}"; then
        right_after_end_mark=1
        inside_section=
      else
        old_section="${old_section}${line}${NL}"
      fi
    fi
  done < "${path}"

  if test "${inside_section}"; then
    err "${path} contains section start without section start"
  fi

  log "Updating ${path} with custom tail lines"
  printf '%s%s\n%s%s\n' "${lines}" "${section_start_mark}" "${section}" \
      "${section_end_mark}" > "${path}"
  file_update=1
}

ensure_dir() {
  local mode group user dir
  mode=
  group=
  user=

  local opt OPTIND
  while getopts :g:m:u: opt; do
    case "${opt}" in
    g ) group="${OPTARG}" ;;
    m ) mode="${OPTARG}" ;;
    u ) user="${OPTARG}" ;;
    * ) getopts_err "${opt}" ;;
    esac
  done
  shift $((OPTIND - 1))

  if test -z "${mode}"; then
    mode=0755
  fi
  if test -z "${user}"; then
    user=root
  fi
  if test -z "${group}"; then
    group="${user}"
  fi

  if test $# -eq 0; then
    return
  fi

  local dir
  for dir in "$@"; do
    test -n "${dir}" || err "directory path cannot be empty"
    test "x${dir}" = "x${dir%/}" || \
        err "directory path must not end with slash - ${dir}"
    test "x${dir}" != "x${dir#/}" || \
        err "directory path must be an absolute path - ${dir}"
    if test ! -d "${dir}"; then
      test ! -e "${dir}" -a ! -h "${dir}"  || \
          err "${dir} exists and is not a directory"
      cmd_log mkdir -m "${mode}" "${dir}"
    else
      test ! -h "${dir}" || \
          err "${path} exists and is a symbilic link, not a directory - ${dir}"
    fi
    local s
    s="$(find "${dir}" \
        -maxdepth 0 -perm "${mode}" -user "${user}" -group "${group}" \
         2>/dev/null || : \
    )"
    if test -z "${s}"; then
      cmd_log chmod "=${mode}" "${dir}"
      cmd_log chown "${user}:${group}" "${dir}"
    fi
    note_path "${dir}"
  done
}

ensure_symlink() {
  local target path
  target="$1"
  path="$2"
  file_update=
  while :; do
    if test -h "${path}"; then
      local current_target
      current_target="$(readlink "${path}")"
      if test "x${current_target}" = "x${target}"; then
        break
      fi
    elif test -d "${path}"; then
      cmd_log rmdir "${path}" || \
        err "remove symbolic link ${path} manually and run again"
    fi
    cmd_log ln -sfT "${target}" "${path}"
    file_update=1
    break
  done
  note_path "${path}"
}

file_update=
file_update_count=0

write_file() {
  local user group mode
  user=
  group=
  mode=
  local opt OPTIND
  while getopts :g:m:u: opt; do
    case "${opt}" in
    g) group="${OPTARG}" ;;
    m) mode="${OPTARG}" ;;
    u) user="${OPTARG}" ;;
    *) getopts_err "${opt}" ;;
    esac
  done

  shift $((OPTIND - 1))
  test $# -eq 2 -o $# -eq 1 || \
      err "write_file takes path and optional body arguments"

  local path body
  path="$1"
  if test $# -eq 2; then
    body="${2}"
  else
    read_stdin
    body="${R}"
  fi
  if test -z "${user}"; then
    user=root
  fi
  if test -z "${group}"; then
    group="${user}"
  fi
  if test -z "${mode}"; then
    mode=0644
  fi

  local wanted_umask need_chmod
  need_chmod=
  case "${mode}" in
  0644) wanted_umask=022 ;;
  0640) wanted_umask=027 ;;
  0600) wanted_umask=077 ;;
  0660) wanted_umask=007 ;;
  0755) wanted_umask=022 need_chmod=1 ;;
  *) err "unsupported mode - ${mode}" ;;
  esac

  local do_update
  do_update=1
  while :; do
    if test ! -f "${path}" -o -h "${path}"; then
      log "creating new ${path}"
      break;
    fi
    local s
    s="$(find "${path}" \
        -maxdepth 0 -perm "${mode}" -user "${user}" -group "${group}" \
        -printf 1 \
    )"
    if test -z "${s}"; then
      log "updating ${path} - permission changes"
      break;
    fi

    if printf %s "${body}" | cmp -s "${path}" -; then
      # Permissions and text matches
      do_update=
      break
    fi

    log "updating ${path} - content changes"
    break
  done

  if test -z "${do_update}"; then
    file_update=
  else
    # Use temporary to ensure atomic operation on filesystem
    local tmp
    tmp="${path}.tmp"
    if test -f "${tmp}"; then
      rm "${tmp}"
    fi

    umask "${wanted_umask}"
    printf %s "${body}" > "${tmp}"
    if test -n "${need_chmod}"; then
      chmod "${mode}" "${tmp}"
    fi
    chown "${user}:${group}" "${tmp}"
    mv -fT "${tmp}" "${path}"

    file_update=1
    : $((file_update_count+=1))
  fi
  note_path "${path}"
}

ensure_removed_file() {
  local path
  path="$1"
  if test -e "${path}" || test -h "${path}"; then
    cmd_log rm "${path}"
  fi
}

ensure_group() {
  local gid
  gid=
  local opt OPTIND
  while getopts :g: opt; do
    case "${opt}" in
    g) gid="${OPTARG}" ;;
    *) getopts_err "${opt}" ;;
    esac
  done
  shift $((OPTIND - 1))

  local group
  group="$1"

  local s
  s="$(getent group "${group}" 2>/dev/null || :)"
  if test -z "${s}"; then
    set --
    if test "${gid}"; then
      set -- "$@" -g "${gid}"
    fi
    cmd_log groupadd "$@" "${group}"
  elif test "${gid}"; then
    local current_gid
    s="${s#*:*:}"
    current_gid="${s%%:*}"
    if test "${current_gid}" != "${gid}"; then
      cmd_log groupmod -g "${gid}" "${group}"
    fi
  fi
}

ensure_user() {
  local create_home home_dir group groups shell system uid
  create_home=
  home_dir=
  group=
  groups=
  shell=
  system=
  uid=
  local opt OPTIND
  while getopts :d:g:G:mrs:u: opt; do
    case "$opt" in
    d) home_dir="$OPTARG" ;;
    g) group="$OPTARG" ;;
    G) groups="$OPTARG" ;;
    m) create_home=1 ;;
    s) shell="$OPTARG" ;;
    r) system=1 ;;
    u) uid="$OPTARG" ;;
    *) getopts_err "$opt" ;;
    esac
  done
  shift $((OPTIND - 1))
  local user_name
  user_name="$1"

  # TODO update on mismatch
  local s
  s="$(getent passwd "$user_name" 2>/dev/null || :)"
  if test -z "$s"; then
    set --
    if test "$create_home"; then
      set -- "$@" -m
    else
      set -- "$@" -M
    fi
    if test "$home_dir"; then
      set -- "$@" -d "$home_dir"
    fi
    if test "$group"; then
      set -- "$@" -g "$group"
    fi
    if test "$groups"; then
      set -- "$@" -G "$groups"
    fi
    if test "$shell"; then
      set -- "$@" -s "$shell"
    fi
    if test "$system"; then
      set -- "$@" -r
    fi
    if test "$uid"; then
      set -- "$@" -u "$uid"
    fi
    cmd_log useradd "$@" "$user"
  else
    local old_name old_uid old_home old_shell
    IFS=: read -r old_name _ old_uid _ _ old_home old_shell <<EOF
$s
EOF
    set --
    test "$old_name" != "$user_name" && \
      err "Unexpected user name: '$old_name' != '$user_name'"
    test "$uid" && test "$uid" != "$old_uid" && \
      err "Change manually user id for the user $user_name from $old_uid to $uid"
    test "$shell" && test "$shell" != "$old_shell" && \
      set -- "$@" -s "$shell"
    test "$home_dir" && test "$home_dir" != "$old_home" && \
      set -- "$@" -d "$home_dir"
    if test $# -ne 0; then
      cmd_log usermod "$@" "$user_name"
    fi

    # TODO: cheeck groups
  fi
}

ensure_group_member() {
  local group user
  group="$1"
  user="$2"
  file_update=
  local s
  s="$(getent group "${group}")"
  if test -z "${s}"; then
    err "group ${group} doesn't exist"
  fi
  s="${s##*:}"
  while test "${s}"; do
    local member
    member="${s%%,*}"
    if test "${member}" = "${user}"; then
      break
    fi
    if test "${member}" = "${s}"; then
      s=
    else
      s="${s#*,}"
    fi
  done
  if test -z "${s}"; then
    cmd_log usermod -aG "${group}" "${user}"
    file_update=1
  fi
}

read_user_home() {
  local user
  user="$1"
  local s
  s="$(getent passwd "${user}")"
  s="${s#*:*:*:*:*:}"
  R="${s%%:*}"
}

read_tliset_name() {
  local path name
  path=/etc/tliset.name
  if test "${under_qubes}"; then
    path="/usr/local${path}"
  fi
  if test "$initialize_tliset_name"; then
    if test -e "$path"; then
      err "With the initial initialization $path must not exist."
    fi
    name="$initialize_tliset_name"
  else
    if test ! -s "${path}"; then
      err "${path} does not exist or empty. Initilize it with a valid name and try again."
    fi
    IFS= read -r name < "${path}"
  fi
  if ! is_valid_host_name "${name}"; then
    err "Unknown name in ${path}: '${name}'"
  fi
  NAME="${name}"
  readonly NAME
}

ensure_masked_service() {
  local service_name s
  service_name="$1"
  s="$(systemctl is-enabled "${service_name}" || :)"
  if test masked != "${s}"; then
    cmd_log systemctl mask "${service_name}"
  fi
}

read_tliset_parent_name() {
  local path name
  path="/etc/tliset.parent_name"
  if ! test -s "${path}"; then
    err "${path} must exists and be non-empty"
  fi
  IFS= read -r name < "${path}"
  if ! is_valid_host_name "${name}" "${valid_primary_host_names}"; then
    err "Unknown name in ${path}: '${name}'." \
        "The name must be one of ${valid_primary_host_names}"
  fi
  PARENT_NAME="${name}"
  readonly PARENT_NAME
}

enable_tormed() {
  local name
  name="$1"
  with_nginx=1
  with_php_fpm=1
  test "${php_version-}" && err "php_version already set"
  php_version=7.4
  webserver_certificate_domains="$webserver_certificate_domains${webserver_certificate_domains:+ }$name"
  tormed_host="$name"
}

add_dns_record_a() {
  local host ipv4
  host="$1"
  ipv4="$2"
  escape_for_shell "--host-record=${host},${ipv4}"
  extra_dnsmasq_eargs="${extra_dnsmasq_eargs} ${R}"
}

add_dns_interface_name() {
  local host interface
  host="$1"
  interface="$2"
  escape_for_shell "--interface-name=${host},${interface}"
  extra_dnsmasq_eargs="${extra_dnsmasq_eargs} ${R}"
}

begin_tliset() {
  paths_file=/var/lib/tliset/paths.txt
  can_note_paths=
  readonly paths_file
  ensure_dir /var/lib/tliset
  exec 9>>"${paths_file}.new"

  can_note_paths=1
  note_path /var/lib/tliset
}

end_tliset() {
  exec 9>&-
  sort "${paths_file}.new" > "${paths_file}.tmp"
  mv "${paths_file}.tmp" "${paths_file}.new"

  # Duplicates happens when tliset runs again after a failure
  uniq "${paths_file}.new" > "${paths_file}.tmp"
  mv "${paths_file}.tmp" "${paths_file}.new"

  if test -f "${paths_file}"; then
    comm -23 "${paths_file}" "${paths_file}.new" > "${paths_file}.unknown"
    filter_existing_paths < "${paths_file}.unknown" > "${paths_file}.tmp"
    mv "${paths_file}.tmp" "${paths_file}.unknown"
    if test -s "${paths_file}.unknown"; then
      log "No longer generated files from the previous runs:" \
          "${NL}$(cat "${paths_file}.unknown")"
      sort "${paths_file}.new" "${paths_file}.unknown" > "${paths_file}.tmp"
      mv "${paths_file}.tmp" "${paths_file}.new"
    else
      rm -f "${paths_file}.unknown"
    fi
  fi

  mv "${paths_file}.new" "${paths_file}"
}

filter_existing_paths() {
  local line
  while IFS= read -r line; do
    if test -e "${line}" -o -h "${line}"; then
      printf '%s\n' "${line}"
    fi
  done
}

note_path() {
  local path
  path="$1"
  if test -n "${can_note_paths}"; then
    printf '%s\n' "${path}" 1>&9
  fi
}

find_device_uuid_by_label() {
  local label s kind uuid
  label="$1"
  s="$(blkid --output export --match-token LABEL="${label}")"
  R=
  while IFS="=" read kind uuid; do
    if test "${kind}" = UUID; then
      test "${#uuid}" -eq 36 || \
        err "Invalid format for UUID for the device with the label" \
          "${label} - ${uuid}"
      test -z "${R}" || \
        err "At least two devices with the label ${label}"
      R="${uuid}"
    fi
  done <<EOF
${s}
EOF
  test "${R}" || err "Failed to find UUID for the device the lable ${label}"
}

setup_packages() {
  log "Checking packages"
  inc_log_level
  if test "$kind_fedora"; then
    setup_rpm_packages
  fi
  if test "$kind_debian" || test "$kind_ubuntu"; then
    setup_apt_packages
  fi
  dec_log_level
  return 0
}


setup_rpm_packages() {
  if test "$with_common_packages" && test "$with_include_rpmfusion"; then
    # Loop over rpmfusion kinds
    set -- free nonfree
    local eargs
    eargs=
    earg rpm -q --quiet
    local i
    for i in "$@"; do
      earg "rpmfusion-$i-release"
    done

    if ! eval "$eargs" ; then
      log "Installing rpmfusion"
      eargs=
      earg dnf install -y --nogpgcheck
      for i in "$@"; do
        earg "http://download1.rpmfusion.org/$i/fedora/rpmfusion-$i-release-$fedora_release.noarch.rpm"
      done
      eval "$eargs" || :
    fi
  fi
  local eargs
  eargs=

  earg lzip lz4 zip unzip
  earg apg ccrypt
  earg git git-subtree quilt
  earg jq
  earg dash screen tmux pv
  earg vim-enhanced

  if test "$with_common_packages"; then
    earg lsyncd
    earg terminus-fonts-console
    earg quilt subversion
    earg git git-subrepo
    earg git-credential-libsecret
    #earg mercurial
    earg livecd-tools
    earg autoconf automake gcc-c++ kernel-devel chrpath
    earg tigervnc
    earg pcp-system-tools strace
    earg xclip
    #earg xpra
    #earg xorg-x11-server-Xephyr
    earg openssh-askpass
    #earg xfce4-terminal

    # filesystems
    earg udftools inotify-tools fdupes rdfind mtools
    earg libguestfs

    # encryption and backup
    earg apg duplicity borgbackup ccrypt

    # Recovery tools
    earg ddrescue foremost scalpel testdisk

    # earg hdparm

    # Graphs
    earg graphviz graphviz-doc

    # PDF tools
    earg pdfmerge poppler-utils

    # Media
    earg gimp inkscape gthumb
    earg scribus
    earg evince evince-djvu pdf2djvu
    earg linux-libertine-biolinum-fonts linux-libertine-fonts
    earg gstreamer1-plugins-good-extras

    # Languages
    earg hunspell-ru hunspell-nb

    # SELinux helpers
    earg libselinux-devel

    if test "$with_include_rpmfusion"; then
      # Archives
      earg unrar libunrar

      # Media
      earg vlc
      earg kdenlive
      earg ffmpeg
      earg gstreamer1-libav
      earg gstreamer1-plugins-bad-free
      earg gstreamer1-plugins-bad-free-extras
      earg gstreamer1-plugins-bad-freeworld
      earg gstreamer1-plugins-ugly
    fi

    if test "$with_firewalld"; then
      earg firewalld
    fi

    earg util-linux

    # earg lm_sensors

    earg gnome-tweaks
    earg gnome-terminal-nautilus

    # Containers
    earg debootstrap
    earg podman

    # Editors
    earg geany
    earg geany-plugins-spellcheck
    earg geany-themes
  fi

  if test "$with_firejail_desktop_rules" || \
      test "$with_common_packages"; then
    earg firejail
  fi

  if test "$with_common_packages" || \
    test "$with_common_development_tools"; then
    earg ShellCheck
  fi

  if test "$with_latex"; then
    earg texlive
    earg texlive-babel-norsk
    earg texlive-hyphen-norwegian
    earg texlive-babel-russian
    earg texlive-collection-langcyrillic
  fi

  if test "$with_setuidless_sshd" || test "$with_custom_sshd"; then
    earg openssh-server
  fi

  earg gcc kernel-devel

  if test "$with_vm_tools"; then
    earg libguestfs-tools
  fi

  if test "$with_remote_ssh_unlock"; then
    earg dracut-network
  fi

  eval "set -- $eargs"
  for i in "$@"; do
    rpm -q --quiet "$i" || log "Missed: $i"
  done

  if ! rpm -q --quiet "$@" ; then
    log "Installing missing packages"
    dnf install -y "$@"
  fi

  # Packages to remove
  local eargs
  eargs=

  if test -n "$eargs"; then
    eval "set -- $eargs"
    local status
    status=0
    rpm -q --quiet "$@" || status=$?
    if test $# -gt "$status"; then
      cmd_log dnf remove -y "$@"
    fi
  fi

  write_file /etc/tmux.conf "new-session$NL"
}

setup_apt_packages() {

  if test "${initialize_tliset_name-}" && test "$with_gui_container_role"; then
    # Restore man pages etc on the first run.
    yes | unminimize
    apt-get update
    DEBIAN_FRONTEND=noninteractive apt-get install tzdata locales
    dpkg-reconfigure locales
    update-locale LANG=en_US.UTF-8
  fi

  local codename name value
  while IFS="=" read -r name value; do
    if test "$name" = VERSION_CODENAME; then
      codename="$value"
      break
    fi
  done < /etc/os-release
  test "$codename" || err "Failed to find VERSION_CODENAME in /etc/os-release"

  if test "$kind_debian"; then
    write_file "/etc/apt/sources.list.d/tliset.list" "\
deb http://deb.debian.org/debian $codename-backports main
"
  fi

  local eargs
  eargs=
  earg file apt-utils apt-file
  earg man-db
  earg rsync
  earg apg ccrypt
  earg zip unzip xz-utils lz4
  earg less screen tmux pv
  earg git quilt
  earg jq shellcheck
  earg iproute2 wget curl netcat-openbsd
  earg git make

  if test "$with_firewalld"; then
    earg firewalld
  fi

  if test "$with_nginx"; then
    earg nginx-full
    earg dehydrated ssl-cert
  fi
  if test "$tormed_host"; then
    earg whois
    earg transmission-daemon

    # Make sure that the default transmission-daemon never starts
    ensure_symlink /dev/null /etc/systemd/system/transmission-daemon.service
    test "$file_update" && systemd_unit_update=1
  fi
  if test "$with_test_lms_container"; then
    earg systemd-container
    earg debootstrap
  fi

  if test "$with_php_fpm"; then
    earg "php$php_version-fpm"
    earg "php$php_version-cli"
    earg "php$php_version-curl"
    earg "php$php_version-mysql"
    earg "php$php_version-sqlite3"
  fi

  if test "$with_common_packages"; then
    # Encryption and backup
    earg lzip lziprecover
    earg ccrypt borgbackup
    earg apg

    earg vim-gui-common
    earg geany geany-plugins geany-plugin-spellcheck

    earg lsyncd
    earg dstat
    earg libreoffice
    #earg libsecret-tools
    #earg ssh-askpass-gnome
    #earg lxqt-openssh-askpass
    #earg qt6-wayland qtwayland5
    #earg gvfs-bin
    #earg libglib2.0-dev
    #earg libgnome-keyring-dev
    earg ffmpeg
    earg xpra
    #earg xephyr
  fi

  if test "$with_firejail_desktop_rules" || \
      test "$with_common_packages"; then
    if test "$kind_debian"; then
      earg "firejail/$codename-backports"
    else
      earg firejail
    fi
    earg xdg-dbus-proxy
  fi

  if test "$with_common_development_tools"; then
    earg python3
    earg gcc g++
    earg manpages-dev
    #earg xauth
  fi

  if test "$with_vm_tools"; then
    earg qemu-utils qemu-system-x86 qemu-system-gui
    earg guestmount fuse3
  fi

  if test "$with_common_packages" || \
    test "$with_common_development_tools"; then
    earg shellcheck
  fi

  if test "$with_latex"; then
    earg texlive
    earg texlive-lang-cyrillic
    earg texlive-lang-european
  fi

  if test "$with_setuidless_sshd" || test "$with_custom_sshd"; then
    earg openssh-server
  fi

  if test "$with_remote_ssh_unlock"; then
    earg dropbear-initramfs
    #earg busybox
  fi

  if test "$with_game_access" || test "$with_user_sandboxes"; then
    earg tigervnc-common tigervnc-standalone-server
    earg ratpoison gnome-terminal
    earg firefox-esr
    earg lxde-core lxterminal openbox openbox-lxde-session
    #earg dbus-x11
    earg vim-gtk3
    earg geany
  fi

  if test "$with_gui_container_role"; then
    earg tzdata locales
    earg gnome-terminal geany
  fi

  local escaped_install_list
  escaped_install_list="${eargs}"

  # Remove list

  eargs=
  earg resolvconf
  if test "${with_dev_container}"; then
    earg networkd-dispatcher rsyslog
    earg wpasupplicant
    earg avahi-daemon
    earg modemmanager
    earg udisks2
    earg cups-daemon
    earg unattended-upgrades
    earg gvfs-common
    earg at-spi2-core
  fi

  if test "${with_persistent_journald}"; then
    earg rsyslog
  fi

  local escaped_remove_list
  escaped_remove_list="${eargs}"

  local escaped_apt_action_list
  escaped_apt_action_list=
  fill_apt_action_list install "$escaped_install_list"
  if test -n "$escaped_apt_action_list"; then
    log "Installing missing packages: $escaped_apt_action_list"
    cmd_log apt-get update
    eval "DEBIAN_FRONTEND=noninteractive \
        cmd_log apt-get install -y $escaped_apt_action_list"
  fi

  escaped_apt_action_list=
  fill_apt_action_list uninstall "$escaped_remove_list"
  if test -n "$escaped_apt_action_list"; then
    log "Purging unnecessary packages $escaped_remove_list"
    eval "DEBIAN_FRONTEND=noninteractive \
        apt-get purge -y $escaped_apt_action_list"
    cmd_log apt-get autoremove -y
  fi

  # Unwanted services that Debian starts by default
  eargs=
  if test "$with_php_fpm"; then
    earg "php$php_version-fpm"
  fi
  local unwanted_services
  unwanted_services="$eargs"
  if test "$unwanted_services"; then
    if eval "systemctl -q is-active $unwanted_services"; then
      eval "cmd_log systemctl stop  $unwanted_services"
    fi
    if eval "systemctl -q is-enabled $unwanted_services"; then
      eval "cmd_log systemctl disable $unwanted_services"
    fi
  fi
}

fill_apt_action_list() {
  local action escaped_package_list
  action="$1"
  escaped_package_list="$2"
  test "$escaped_package_list" || return 0

  # Strip /variant from package names
  eval "set -- $escaped_package_list"
  local eargs name
  eargs=
  for name in "$@"; do
    earg "${name%%/*}"
  done
  eval "set -- $eargs"

  # Complication: for unknown packages dpkg-query reports an error,
  # so parse both stdout and stderr.
  local status_package_prefix
  local unknown_package_message_prefix
  local unknown_package_message_prefix2
  status_package_prefix='#stdout '
  unknown_package_message_prefix='dpkg-query: no packages found matching '

  local output
  output="$(dpkg-query -W --showformat \
      '#stdout ${db:Status-Abbrev} ${Package}\n' "$@"  2>&1 || : \
  )"
  if test -z "${output}"; then
    return 0
  fi

  # Parse lines in the output using herestring redirect
  {
    while IFS= read -r line; do
      local package status
      case "${line}" in
      "dpkg-query: "* )
        # Error line, assume it is about our package
        package="${line##* }"
        case "${package}" in
        "" | *" "*)
          err "unexpected dpkg-query unknown package line: '${line}'"
          ;;
        *) ;;
        esac
        status='unknown'
        ;;
      "${status_package_prefix}"* )
        line="${line#"${status_package_prefix}"}"
        status="${line%%"  "*}"
        package="${line#*"  "}"
        case "${status}" in
        ii ) status=installed ;;
        un ) status=uninstalled ;;
        rc ) status=config-files ;;
        * ) err "unexpected dpkg-query status '${status}': '${line}'" ;;
        esac
        case "${package}" in
        "" | *" "*)
          err "unexpected dpkg-query status: '${line}'"
          ;;
        *) ;;
        esac
        ;;
      *) err "unexpected dpkg-query output: ${line}" ;;
      esac
      case "${action}" in
      install)
        if test installed = "${status}"; then
          continue
        fi
        ;;
      uninstall)
        # purge both installed packages and packages with config-files
        if test installed != "${status}" && test config-files != "${status}"; then
          continue
        fi
        ;;
      *) err "bad action: ${action}" ;;
      esac
      escape_for_shell "${package}"
      escaped_apt_action_list="${escaped_apt_action_list} ${R}"
    done
  } << EOF
${output}
EOF
}

start_generator_write() {
  multi_user_wants_list=
  basic_target_wants_list=
  systemd_unit_update=
  service_start_list=
  service_try_restart_list=
  service_restart_list=
  service_reload_list=
  systemd_tmpfile_lines=
}

add_multi_user_wants() {
  local eargs
  eargs="${multi_user_wants_list}"
  earg "$@"
  multi_user_wants_list="${eargs}"
}

add_basic_target_wants() {
  local eargs
  eargs="${basic_target_wants_list}"
  earg "$@"
  basic_target_wants_list="${eargs}"
}

add_service_start() {
  local eargs
  eargs="${service_start_list}"
  earg "$@"
  service_start_list="${eargs}"
}

add_service_try_restart() {
  local eargs
  eargs="${service_try_restart_list}"
  earg "$@"
  service_try_restart_list="${eargs}"
}

add_service_restart() {
  local eargs
  eargs="${service_restart_list}"
  earg "$@"
  service_restart_list="${eargs}"
}

add_service_reload() {
  local eargs
  eargs="${service_reload_list}"
  earg "$@"
  service_reload_list="${eargs}"
}

add_systemd_tmpfile_entry() {
  systemd_tmpfile_lines="${systemd_tmpfile_lines}$*${NL}"
}

print_wants_list() {
  local target
  target="$1"
  shift
  test $# -ne 0 || return 0
  local lines i
  lines=
  pl "[Unit]"
  for i in "$@"; do
    pl "Wants=${i}"
  done
  p_systemd_drop_in "${target}" "${lines}"
}

# shellcheck disable=SC2120
finish_generator_write() {
  finish_systemd_changes
}

finish_systemd_changes() {
  if test "${systemd_tmpfile_lines}"; then
    write_file /etc/tmpfiles.d/tliset.conf "${systemd_tmpfile_lines}"
    if test "${file_update}"; then
      cmd_log systemd-tmpfiles --create /etc/tmpfiles.d/tliset.conf
    fi
  fi

  eval "print_wants_list multi-user.target ${multi_user_wants_list}"
  eval "print_wants_list basic.target ${basic_target_wants_list}"
  if test "${systemd_unit_update}"; then
    cmd_log systemctl daemon-reload
  fi
  if test "${service_restart_list}"; then
    eval "cmd_log systemctl restart ${service_restart_list}"
  fi
  if test "${service_try_restart_list}"; then
    eval "cmd_log systemctl try-restart ${service_try_restart_list}"
  fi
  if test "${service_reload_list}"; then
    eval "cmd_log systemctl try-reload-or-restart ${service_reload_list}"
  fi
  if test "${service_start_list}"; then
    # Use explicit loop with a status query to log nothing unless we start
    # something.
    local eargs
    eargs=
    eval "set -- ${service_start_list}"
    local service
    for service in "$@"; do
      if ! systemctl --quiet is-active "${service}"; then
        earg "${service}"
      fi
    done
    if test -n "${eargs}"; then
      eval "cmd_log systemctl start ${eargs}"
    fi
  fi
}

# The first argument is <kind>:<subpath> where kind specifies
# directory kind and subpath is a file path. The second argument is
# text that should be written into the file at that path. Option -x
# indicattes that file must be executable.
p_file() {
  local executable
  executable=
  case "$1" in
  -x) shift; executable=1 ;;
  *) ;;
  esac
  local file_kind_and_path body
  file_kind_and_path="$1"
  body="$2"
  local path
  convert_kind_path "${file_kind_and_path}"
  path="${R}"

  set --
  if test -n "${executable}"; then
    set -- "$@" -m 0755
  fi
  write_file "$@" "$path" "$body"
  if test "$file_update"; then
    case "${file_kind_and_path}" in
    service:*) systemd_unit_update=1 ;;
    *) ;;
    esac
  fi
}

p_dir() {
  local dir
  dir="$1"
  convert_kind_path "${dir}"
  dir="${R}"
  ensure_dir "${dir}"
}

p_ensure_no_file() {
  local file
  file="$1"
  convert_kind_path "${file}"
  file="${R}"
  file_update=
  if test -f "${file}"; then
  cmd_log rm -f "${file}"
  file_update=1
  fi
}

p_ensure_no_dir() {
  local dir
  dir="$1"
  convert_kind_path "${dir}"
  dir="${R}"
  if test -d "${dir}"; then
  cmd_log rmdir "${file}"
  fi
}

p_symlink() {
  local target path
  target="$1"
  path="$2"
  convert_kind_path "${path}"
  path="${R}"
  ensure_symlink "${target}" "${path}"
}

p_systemd_drop_in() {
  local path_kind
  path_kind=service
  if test "$1" = --user; then
    path_kind=user-service
    shift
  fi
  local unit_name
  unit_name="$1"
  drop_in_text="$2"

  p_dir "${path_kind}:${unit_name}.d"
  p_file "${path_kind}:${unit_name}.d/tliset.conf" "${drop_in_text}"
}

convert_kind_path() {
  local arg file_kind file_path
  arg="$1"
  file_kind="${arg%%:*}:"
  file_path="${arg#*:}"
  if test "${file_path}" = "${arg}"; then
    if test "${arg}" = "${arg}#/"; then
      err "The raw path argument must be an absolute path - ${arg}"
    fi
    R="${arg}"
    return
  fi
  local dir
  case "${file_kind}" in
  net: ) dir='/etc/systemd/network' ;;
  nspawn: ) dir="/etc/systemd/nspawn" ;;
  nginx-site: ) dir="/etc/nginx/sites-enabled" ;;
  nginx-config: ) dir="/etc/nginx/conf.d" ;;
  service: ) dir='/etc/systemd/system' ;;
  scripts: ) dir="/var/lib/tliset" ;;
  sysctl: ) dir="/etc/sysctl.d" ;;
  user-service: ) dir='/etc/systemd/user' ;;
  NetworkManager: ) dir="/etc/NetworkManager/conf.d" ;;
  * ) err "Unknown file kind - ${file_kind_and_path}" ;;
  esac
  ensure_dir "${dir}"

  if test -z "${file_path}"; then
    R="${dir}"
    return 0
  fi
  case "${file_path}" in
  /*) err "the path part must be a relative path: ${file_kind_and_path}" ;;
  *) ;;
  esac
  R="${dir}/${file_path}"
}

p_mask_service() {
  p_symlink /dev/null "service:$1"
}

setup_kernel_parameters() {
  setup_zram
  setup_zswap

  local lines
  lines=""
  if test -n "${custom_user_watches_count}"; then
    pl "fs.inotify.max_user_watches=${custom_user_watches_count}"
  fi
  if test "${zram_size}" || test "${zswap_persent}"; then
    # See https://www.reddit.com/r/Fedora/comments/mzun99/new_zram_tuning_benchmarks/
    pl "vm.page-cluster=0"
    pl "vm.swappiness=130"
  fi

  if test -n "${lines}"; then
    p_file sysctl:50-tliset.conf "${lines}"
  else
    p_ensure_no_file sysctl:50-tliset.conf
  fi

  if test "${with_disabled_turbo_boost}"; then
    # https://www.kernel.org/doc/html/v4.14/admin-guide/pm/intel_pstate.html
    local unit
    unit=tliset-disable-turbo.service
    p_file "service:${unit}" '
[Service]
Type=oneshot
ExecStart=/bin/sh -c "printf 1 > /sys/devices/system/cpu/intel_pstate/no_turbo"
ExecStop=/bin/sh -c "printf 0 > /sys/devices/system/cpu/intel_pstate/no_turbo"
RemainAfterExit=yes
'
    add_basic_target_wants "${unit}"
  fi
}

setup_initramfs_and_grub() {
  local dracut_lines grub_lines
  dracut_lines=
  grub_lines=

  if test "${with_remote_ssh_unlock}"; then
    if test "${kind_ubuntu}" || test "${kind_debian}"; then
      # This is based on
      # https://hamy.io/post/0009/how-to-install-luks-encrypted-ubuntu-18.04.x-server-and-enable-remote-unlocking/
      # After the login at boot time use cryptroot-unlock command
      write_file /etc/dropbear-initramfs/config '
DROPBEAR_OPTIONS="-p 21 -s -j -k -I 120"
'
      if test "${file_update}"; then
        update_initram=1
      fi

      local authorized_keys
      authorized_keys=
      if test -s /root/.ssh/authorized_keys; then
        authorized_keys="$( \
            grep '^ssh-rsa ' /root/.ssh/authorized_keys \
        )${NL}"
      fi
      if test -z "${authorized_keys}"; then
        warn "/root/.ssh/authorized_keys does not have RSA keys for dropbear" \
            "boot unlock"
      fi
      write_file /etc/dropbear-initramfs/authorized_keys "${authorized_keys}"
      if test "${file_update}"; then
        cmd_log update-initramfs -u
      fi
    elif test "${kind_fedora}"; then
      # Use systemd-tty-ask-password-agent during the login
      if test ! -d /usr/lib/dracut/modules.d/46sshd ; then
        err "Install https://github.com/gsauthof/dracut-sshd"
      fi

      # Use systemd-networkd at boot
      dracut_lines="${dracut_lines}"'
add_dracutmodules+=" systemd-networkd "
omit_dracutmodules+="ifcfg network-legacy network-manager"
'
    else
      err "Unsupported OS kind for with_remote_ssh_unlock"
    fi
  fi

  if test "${with_hibernation}"; then
    if test "${kind_fedora}"; then
      dracut_lines="${dracut_lines}"'
add_dracutmodules+=" resume "
'
      local swap_uuid
      find_device_uuid_by_label swap
      swap_uuid="${R}"
      grub_lines="${grub_lines}"'
GRUB_CMDLINE_LINUX="${GRUB_CMDLINE_LINUX} resume=UUID='"${swap_uuid}"'"
'
      local unit_fragment
      unit_fragment='
[Service]
Environment=SYSTEMD_BYPASS_HIBERNATION_MEMORY_CHECK=1
'
      p_systemd_drop_in systemd-logind.service "${unit_fragment}"
      if test "${file_update}"; then
        # Restart while logged in does not work for some reason
        log "Rebbot the system to ensure systemd-logind restart"
        # add_service_try_restart systemd-logind.service
      fi
      p_systemd_drop_in systemd-hibernate.service "${unit_fragment}"
      if test "${file_update}"; then
        log "Rebbot the system to ensure systemd-hibernate restart"
        # add_service_try_restart systemd-hibernate.service
      fi

      # Configure suspend-then-hibernate after 30 minutes and make any suspend
      # to hibernate eventually.

      local sleep_fragment
      sleep_fragment='
[Sleep]
HibernateDelaySec=30min
'
      ensure_dir /etc/systemd/sleep.conf.d
      write_file /etc/systemd/sleep.conf.d/tliset.conf "${sleep_fragment}"
      if test "${file_update}"; then
        log "Rebbot to ensure the sleep.conf changes are taken into account"
      fi

      local service
      service=/usr/lib/systemd/system/systemd-suspend-then-hibernate.service
      test -f "${service}" || err "${service} file does not exist"
      ensure_symlink "${service}" /etc/systemd/system/systemd-suspend.service
      if test "${file_update}"; then
        systemd_unit_update=1
      fi
    else
      err "Unsupported OS kind for with_hibernation"
    fi
  fi

  if test "${dracut_lines}"; then
    write_file /etc/dracut.conf.d/tliset.conf "${dracut_lines}"
    if test "${file_update}"; then
      cmd_log dracut -f -v
    fi
  fi

  if test "${grub_lines}"; then
    ensure_config_file_tail_section /etc/default/grub "${grub_lines}"
    if test "${file_update}"; then
      cmd_log grub2-mkconfig -o /boot/grub2/grub.cfg
    fi
  fi
}

setup_filesystems() {
  if test -d /etc/udisks2; then
    # Setup default options for user-mountanable drives
    write_file /etc/udisks2/mount_options.conf '
[defaults]
defaults=noatime
#btrfs_defaults=compress=zstd:1
'
  fi
}

setup_log() {
  test "${with_persistent_journald}" || return 0

  ensure_dir /etc/systemd/journald.conf.d
  write_file /etc/systemd/journald.conf.d/tliset.conf "\
[Journal]
Storage=persistent
ForwardToSyslog=no
"
  if test "${file_update}"; then
    cmd_log systemctl restart systemd-journald.service
    cmd_log journalctl --flush
  fi
}

setup_zram() {
  if test -z "${zram_size}"; then
    # Ensure zram is disabled
    if test -f /usr/lib/systemd/zram-generator.conf ; then
      ensure_symlink /dev/null /etc/systemd/zram-generator.conf
    fi
    return 0
  fi

  log "Checking zram"

  local lines
  if test -f /usr/lib/systemd/zram-generator.conf ; then
    lines=""
    pl "[zram0]"
    pl "zram-size=${zram_size}"
    if test "${zram_algorithm}"; then
      pl "compression-algorithm=${zram_algorithm}"
    fi
    if test "${zram_writeback}"; then
      test -b "${zram_writeback}" || \
          err "${zram_writeback} does not exist or is not a block device." \
            "If necessary, use swaplabel or similar command to change" \
            "the label."
      pl "writeback-device=${zram_writeback}"
    fi

    p_file /etc/systemd/zram-generator.conf "${lines}"
    return 0
  fi

  local alg_arg
  alg_arg=
  if test -n "${zram_algorithm}"; then
    alg_arg=" --algorithm ${zram_algorithm}"
  fi

  write_file -m 0755 /var/lib/tliset/zram-control \
'#!/bin/sh

set -e -u;

zram_size='"${zram_size}"'
zram_algorithm='"${zram_algorithm}"'
zram_writeback='"${zram_writeback}"'


start() {
  printf "" > /run/tliset-zram-state
  local device
  device="$(zramctl --find 2>/dev/null || :)"
  if test -z "${device}"; then
    # zram can be compiled as a module
    modprobe zram
    device="$(zramctl --find || :)"
    if test -z "${device}"; then
      echo "Failed to find a zram device" >&2; exit 1
    fi
  fi
  echo "device ${device}" >> /run/tliset-zram-state
  local zram_dir
  zram_dir="/sys/block/${device##*/}"
  if ! test -d "${zram_dir}"; then
    echo "zram config directory does not exist - ${zram_dir}" >&2; exit 1
  fi
  if test "${zram_algorithm}"; then
    printf "%s\\n" "${zram_algorithm}" > "${zram_dir}/comp_algorithm"
  fi
  if test "${zram_writeback}"; then
    zram_writeback="$(realpath "${zram_writeback}")"
    printf "%s\\n" "${zram_writeback}" > "${zram_dir}/backing_dev"
  fi
  printf "%s\\n" "${zram_size}M" > "${zram_dir}/disksize"
  /sbin/mkswap "${device}"
  /sbin/swapon -p 100 "${device}"
  echo "after_swapon 1" >> /run/tliset-zram-state
  swappiness=
  read -r swappiness < /proc/sys/vm/swappiness || :
  echo "original_swappiness ${swappiness}" >> /run/tliset-zram-state
  printf 100 > /proc/sys/vm/swappiness
}

stop() {
  local arg value device after_swapon original_swappiness
  device=
  after_swapon=
  original_swapiness=
  while read -r arg value; do
    case "${arg}" in
    device | after_swapon | original_swappiness ) readonly "${arg}=${value}" ;;
    * ) echo "Unknown key in /run/tliset-zram-state - $arg";;
    esac
  done < /run/tliset-zram-state
  if test "${original_swappiness-}"; then
    printf "%s\\n" "${original_swappiness}" > /proc/sys/vm/swappiness || :
  fi
  if test "${device}"; then
    if test "${after_swapon}"; then
      /sbin/swapoff "${device}" || :
    fi
    local zram_dir
    zram_dir="/sys/block/${device##*/}"
    printf "reset\\n" > "${zram_dir}/reset"
  fi
  rm /run/tliset-zram-state
}

case "$1" in
start) start ;;
stop) stop ;;
*) echo "Unknown action - $1" >&2; exit 1 ;;
esac
'

  # shellcheck disable=SC1004,SC2016
  p_file service:tliset-zram.service '
[Unit]
Description=Service enabling RAM compression using zRam

[Install]
WantedBy=multi-user.target

[Service]
Type=oneshot
ExecStart=/var/lib/tliset/zram-control start
ExecStopPost=/var/lib/tliset/zram-control stop
RemainAfterExit=yes
'
  add_multi_user_wants tliset-zram.service

}

setup_zswap() {
  test "${zswap_persent}" || return 0

  log "Checking zswap"

  local unit
  unit=tliset-zswap.service
  p_file "service:${unit}" '
[Service]
Type=oneshot
ExecStart=/bin/sh -c "\
  cd /sys/module/zswap/parameters && \
  printf 1 > enabled && \
  printf '"${zswap_persent}"' > max_pool_percent && \
  printf lz4 > compressor && \
  printf z3fold  > zpool"
ExecStop=/bin/sh -c "printf 0 > /sys/module/zswap/parameters/enabled"
RemainAfterExit=yes
'
  add_basic_target_wants "${unit}"

  write_file -m 0755 /var/lib/tliset/zswap-stats <<'EOF'
#!/bin/sh
set -e -u
dir=/sys/kernel/debug/zswap
cd "${dir}" || {
  echo "Failed to change to ${dir} directory." \
    "This should be invoked with root priviliges." >&2
  exit 1
}
grep -R . .
echo ""
read stored_pages < stored_pages
read pool_total_size < pool_total_size
if test "${pool_total_size}" -eq 0; then
  echo "Empty pool"
else
  pool_size_mb=$((pool_total_size / 1024 / 1024))
  echo "Pool size:" \
    "$((pool_size_mb / 1024)).$(((pool_size_mb * 1000 / 1024) % 1000))GB"
  echo "Compressed ratio: $((stored_pages * 4096 * 100 / pool_total_size))%"
fi
EOF
}

setup_network() {
  log "Checking network"
  inc_log_level

  # To ensure network connectivity for the following operations restart
  # services on return.
  local restart_systemd_networkd
  local restart_systemd_resolved
  restart_systemd_networkd=
  restart_systemd_resolved=

  setup_network_manager

  if test "${with_stub_resolv_conf}"; then
    ensure_symlink /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf
    test "${file_update}" && restart_systemd_resolved=1
    add_multi_user_wants systemd-resolved.service
  fi

  if test "${with_forced_networkd}"; then
    if systemctl --quiet is-enabled NetworkManager 2>/dev/null; then
      cmd_log systemctl disable NetworkManager
    fi
    add_multi_user_wants systemd-resolved.service
    add_multi_user_wants systemd-networkd.service

    if systemctl --quiet is-active NetworkManager; then
      cmd_log systemctl stop NetworkManager
    fi

    if ! systemctl --quiet is-active systemd-networkd.service; then
      restart_systemd_networkd=1
    fi
    if ! systemctl --quiet is-active systemd-resolved.service; then
      restart_systemd_network=1
    fi
    if test "${kind_debian}"; then
      # TODO Make this reversable, perhaps via a generator.
      ensure_masked_service networking.service
    fi
  fi

  if test "${with_dev_container}"; then
    write_file "/etc/hostname" "${PARENT_NAME}-${NAME}${NL}"
    write_file /etc/hosts "127.0.0.1 localhost ${PARENT_NAME}-${NAME}${NL}"

    # ensure that /etc/resolv.conf is a plain file that can be bind-mounted
    if ! test -f /etc/resolv.conf; then
      rm -f /etc/resolv.conf
      printf '' > /etc/resolv.conf
    fi
  fi

  # Lines for resolved.conf
  local lines
  lines=
  if test "$with_encrypted_dns"; then
    pl "DNS=1.1.1.1"
    pl "DNSOverTLS=yes"
    #pl "DNSSEC=allow-downgrade"
    pl "DNSSEC=no"
    pl "Domains=~."
  fi

  if test "${lines}"; then
    lines="[Resolve]${NL}${lines}"
    ensure_dir /etc/systemd/resolved.conf.d
    write_file /etc/systemd/resolved.conf.d/99-tliset.conf "${lines}"
    if test "${file_update}"; then
      restart_systemd_resolved=1
    fi
  fi

  if test "${restart_systemd_networkd}"; then
    cmd_log systemctl restart systemd-networkd.service
    cmd_log sleep 1
  fi
  if test "${restart_systemd_resolved}"; then
    cmd_log systemctl restart systemd-resolved.service
  fi

  dec_log_level
}

setup_network_manager() {
    local reload_network_manager
    reload_network_manager=

  if ! :; then
    if test -h /etc/resolv.conf; then
      cmd_log rm -f /etc/resolv.conf
      cmd_log touch /etc/resolv.conf
    fi

    p_file NetworkManager:tliset.conf "\
[main]
dns=dnsmasq
#dns=systemd-resolved
rc-manager=file

[keyfile]
unmanaged-devices=interface-name:ve-*
"
    test "$file_update" && reload_network_manager=1
  fi

  if test "$with_encrypted_dns" || test "$with_mdns"; then
    local dispatcher_script
    dispatcher_script=\
'#!/bin/sh

set -e -u
set -f
readonly DEFAULT_IFS="${IFS}"

log() {
  logger -t "tliset.network" "$*"
  #printf "%s\\n" "$*" >&2
}

cmd_log() {
  log "$@"
  "$@"
}

interface="$1"
action="$2"
'
    if test "$with_encrypted_dns"; then
      dispatcher_script="$dispatcher_script"'
# Remove any default domain to force always using the global DNS
if test "$action" = up; then
  domains="$(resolvectl domain "$interface")"
  domains="${domains##*:}"
  has_match_all=
  has_domains=
  set --
  for domain in ${domains}; do
    if test "~." = "$domain"; then
      has_match_all=1
    else
      set -- "$@" "$domain"
      has_domains=1
    fi
  done
  if test -n "${has_match_all}"; then
    # To clear the list an empty string should be passed as a single argument
    test 0 -eq "$#" && set -- ""
    cmd_log resolvectl domain "${interface}" "$@"
  fi

  if test "${has_domains}"; then
    # NetworkManager does not support setting dnssec and dnsovertls on the
    # per-connection basis. Assume for now that dnssec and dnsovertls is not
    # supported for domain-specific servers.
    cmd_log resolvectl dnsovertls "${interface}" opportunistic
    cmd_log resolvectl dnssec "${interface}" allow-downgrade
    cmd_log resolvectl default-route "${interface}" no
  fi
fi
'
    fi
    if test "$with_mdns"; then
      dispatcher_script="$dispatcher_script"'
if test "$action" = up; then
  cmd_log resolvectl mdns "$interface" resolve
fi
'
    fi

    ensure_dir /etc/NetworkManager/dispatcher.d
    write_file -m 0755 /etc/NetworkManager/dispatcher.d/50-tliset \
        "$dispatcher_script"
  fi

  if test "${reload_network_manager}"; then
    cmd_log systemctl try-reload-or-restart NetworkManager
  fi
}

setup_users() {
  if test "${with_gui_container_role}"; then
    ensure_user -s /bin/bash "${main_user}"
    ensure_dir -m 0770 -g "${main_user}" -u root "/home/${main_user}"
    ensure_group -g "${container_socket_access_subgid}" tliset-gui-sockets
    ensure_group_member tliset-gui-sockets "${main_user}"
  fi
}

setup_services() {
  log "Checking services"
  inc_log_level

  if test "${with_dev_container}"; then
    write_file "/etc/default/locale" "LANG=C.UTF-8${NL}"
    ensure_symlink "/lib/systemd/system/multi-user.target" \
      "/etc/systemd/system/default.target"

    # Disable unnecesary services
    ensure_masked_service cron
    ensure_masked_service console-getty
    ensure_masked_service apache2.service

    # The container shares the networking with the host, so disable any
    # networking services
    ensure_masked_service systemd-networkd
    ensure_masked_service systemd-resolved
    ensure_masked_service networkd-dispatcher
  fi

  if test "${with_disabled_selinux}"; then
    if ! test -f /etc/selinux/config.orig; then
      cp -a /etc/selinux/config /etc/selinux/config.orig
    fi
    write_file /etc/selinux/config "SELINUX=disabled$NL"
  fi

  if test "$with_disabled_firewalld"; then
    ensure_masked_service firewalld
  fi

  setup_lms_archive
  setup_nginx_service
  setup_tormed_service
  setup_game_access_service
  setup_containers
  setup_test_lms_container
  setup_firejail_desktop_rules
  setup_user_sandboxes

  dec_log_level
}

setup_lms_archive() {
  test -n "${lms_archive_time}" || return 0

  if test manual = "${lms_archive_time}"; then
    return 0
  fi

  case "${lms_archive_time}" in
  [0-2][0-9]:[0-5][0-9]:[0-5][0-9]) ;;
  *)
    err "Invalid backup time spec in lms_archive_time" \
        "- '${lms_archive_time}'"
    ;;
  esac

  ensure_user -d "${lms_archive_root}" tliset-lms-archive
  ensure_dir "${lms_archive_root%/*}"

  # Initialize new skeleton structure if the directory does not exist.
  if ! test -d "${lms_archive_root}"; then
    local d
    d="${lms_archive_root}.tmp"
    cmd_log rm -rf "${d}"
    cmd_log mkdir -m 0770 "${d}"
    cmd_log mkdir -m 0700 "${d}/.ssh"
    cmd_log ssh-keygen -t ed25519 -N '' -f "${d}/.ssh/id_ed25519" \
        -C "tliset-lms-archive@${NAME} $(date +%Y-%m-%d)"
    cmd_log chown -R tliset-lms-archive:tliset-lms-archive "${d}/.ssh"
    cmd_log mv -T "${d}" "${lms_archive_root}"
    cmd_log cat "${lms_archive_root}/.ssh/id_ed25519.pub"
  fi

  # Now ensure the ownership as we no longer touch files under the directory.
  ensure_dir -m 0770 -g tliset-lms-archive "${lms_archive_root}"

  p_file service:tliset-lms-archive.timer "\
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
OnCalendar=${lms_archive_time}
"
  p_file service:tliset-lms-archive.service '
[Unit]
After=network-online.target
Wants=network-online.target

[Service]
User=tliset-lms-archive
ExecStart=/var/lib/tliset/lms-archive
StandardError=journal
StandardOutput=journal
Type=oneshot

ReadWritePaths='"${lms_archive_root}"'

NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
'
  add_multi_user_wants "tliset-lms-archive.timer"

  # Script source with condition code
  local s
  s='#!/bin/sh
set -e -u

# Number of days to keep old backups in the changed dir
max_keep_changed_days=90

'
  # On fedora change SELinux context for rsync so it is treated as
  # a binary, not a service. As an update can reset it, do it each
  # time we are about to run it.
  if test -n "${kind_fedora}"; then
    # shellcheck disable=SC2016
    s="${s}"'
se_context="$(stat -c %C /usr/bin/rsync)"
case "${se_context}" in
*:*:*:* )
  se_type="${se_context#*:*:"}"
  se_type="${se_type%%:*}"
  if test "${se_type}" != bin_t; then
    echo "Changing SE context for /usr/bin/rsync from ${se_type} to bin_t" 1>&2
    chcon -t bin_t /usr/bin/rsync
  fi
esac
'
  fi
  # shellcheck disable=SC1004,SC2016
  s="${s}"'

readonly backup_root="'"${lms_archive_root}"'"

backup_from_host() {
  local host_name="$1"
  local files="$backup_root/${host_name}"
  local changes="$backup_root/changes/${host_name}"
  local partial="$backup_root/rsync-partial/${host_name}"
  local dir
  for dir in "$files" "$changes" "$partial"; do
    if ! test -d "${dir}"; then
      mkdir -p "${dir}"
    fi
  done

  local ssh_cmd
  ssh_cmd="ssh -l lms-backup"
  ssh_cmd="${ssh_cmd} -o Ciphers=aes128-gcm@openssh.com"
  ssh_cmd="${ssh_cmd} -o StrictHostKeyChecking=no"

  # Argumets to rsync
  set --
  set -- "$@" -rlpt
  set -- "$@" --no-owner --no-group --omit-dir-times --omit-link-times
  set -- "$@" --partial-dir="${partial}" --delete-after
  set -- "$@" --info=NAME
  set -- "$@" --rsh="${ssh_cmd}"

  local too_old_backup="$changes/$(date --date="-20 days" +%Y-%m-%d)"
  rm -rf "$too_old_backup"
  local changed_files
  changed_files="$changes/$(date +%Y-%m-%d)"
  mkdir -p "${changed_files}"

  echo "Backing up ${host_name}" >&2
  local ok=1
  rsync "$@" --backup --backup-dir="${changed_files}" \
    "rsync://$host_name/lms/" "$files/lms/" || ok=

  # Detect older changes to remove
  set --
  if test "${ok}"; then
    local i cur_time dir_time
    cur_time="$(date +%s)"
    for i in "${changes}"/*; do
      dir_time="$(stat -c %Y "${i}")"
      if test "$((cur_time-dir_time))" -gt \
          "$((max_keep_changed_days*86400))"; then
        set -- "$@" "$i"
      fi
    done
  fi
  if test "$#" -gt 0; then
    echo "removing older changes created more than" \
      "$max_keep_changed_days days ago:"
    printf "\\n\\t%s" "$@"
    rm -rf "$@"
  fi
}

backup_from_host bergenrabbit.net
'

  write_file -m 0755 "/var/lib/tliset/lms-archive" "${s}"

  if test -n "${kind_fedora}"; then
    setsebool rsync_client 1
  fi
}

setup_sshd() {

  test "${with_custom_sshd}" || test "${with_dev_container}" || return 0

  #ensure_user -r -d /

  # sshd_config lines
  local lines
  lines="\
Subsystem sftp  /usr/lib/openssh/sftp-server
"

  local use_pam
  use_pam=yes
  if test "$with_setuidless_sshd" && test "$kind_fedora"; then
    # Fedora uses setuid helper for PAM that is broken with
    # with_setuidless_sshd
    use_pam=no
  elif test "$with_user_sandboxes"; then
    # PAM makes things too complicated
    use_pam=no
  fi
  pl "UsePAM ${use_pam}"

  if test "${with_dev_container}"; then
    pl "Port 12022"
    pl "ListenAddress 127.0.0.1"
  fi

  if test "${with_gui_container_role}"; then
    pl 'AuthorizedKeysFile /run/ssh_authorized_keys/%u .ssh/authorized_keys'
  fi

  # User sessions

  setup_user_sandboxes sshd_config

  if test "$with_game_access"; then
    lines="$lines
Match User game
  ChrootDirectory /srv/game
  ForceCommand internal-sftp -u 0007
  AllowTcpForwarding all
  AllowStreamLocalForwarding all
  PasswordAuthentication yes
"
  fi

  lines="$lines
Match All
  PasswordAuthentication no
  ChallengeResponseAuthentication no

  X11Forwarding yes
  PrintMotd no

# AcceptEnv LANG LC_*
"

  write_file /etc/ssh/sshd_config "$lines"

  local ssh_service_name
  if test "$kind_debian" || test "$kind_ubuntu"; then
    ssh_service_name=ssh
  elif test "$kind_fedora"; then
    ssh_service_name=sshd
  else
    err "ssh service name is not known on this system"
  fi

  if test "$file_update"; then
    add_service_reload "$ssh_service_name.service"
  fi

  if test -n "${with_setuidless_sshd}"; then
    local ssh_drop_in
    ssh_drop_in="\
[Service]
NoNewPrivileges=yes
"
    p_systemd_drop_in "${ssh_service_name}.service" "${ssh_drop_in}"
  fi

  add_multi_user_wants "${ssh_service_name}.service"

  if test "${with_dev_container}"; then
    ensure_dir -m 0700 /root/.ssh
    if test ! -s /root/.ssh/authorized_keys; then
      local public_key
      public_key=
      printf '%s\n' "Enter ssh public key for the root access: "
      IFS= read -r public_key || :
      test "${public_key}" || err "Cannot proceed without public key"
      if test "${#public_key}" -lt 80; then
        err "The public key is too short: ${public_key}"
      fi
      # Do not note as we write conditionally on file non-existance
      can_note_paths=
      write_file -m 0600 /root/.ssh/authorized_keys "${public_key}${NL}"
      can_note_paths=1
    fi
  fi
}

setup_firejail_desktop_rules() {
  test "$with_firejail_desktop_rules" || return 0

  write_file /etc/firejail/disable-common.local '
blacklist ${HOME}/Private
read-only ${HOME}/a
read-only ${HOME}/p
'
}

setup_user_sandboxes() {
  test "$with_user_sandboxes" || return 0

  local user_sandbox_accounts
  user_sandbox_accounts="igor game"

  if test "${1-}" == sshd_config; then
    local user_name
    for user_name in $user_sandbox_accounts; do
      pl "Match User $user_name"
      pl "  PasswordAuthentication no"
      pl "  #ForceCommand /var/lib/tliset/user-sandbox-enter \$SSH_ORIGINAL_COMMAND"
      pl "  ForceCommand /var/lib/tliset/force-into-user-sandbox"
    done
    return 0
  elif test "${1-}"; then
    err "unknown subaction $1"
  fi

  write_file -m 0755 /var/lib/tliset/force-into-user-sandbox \
'#!/bin/sh

set -e -u

user_id="$(id -u)"
XDG_RUNTIME_DIR="/run/user/$user_id"
export XDG_RUNTIME_DIR

set -- systemd-run --user

set -- "$@" --service-type=exec
set -- "$@" --wait --collect
set -- "$@" --pipe --tty
set -- "$@" --quiet
set -- "$@" "$SHELL"
if test "${SSH_ORIGINAL_COMMAND-}"; then
  set -- "$@" -c "$SSH_ORIGINAL_COMMAND"
else
  set -- "$@" -l
fi

exec "$@"
'
  local user_name
  for user_name in $user_sandbox_accounts; do
    ensure_user -m -s /bin/bash "$user_name"
    ensure_dir -m 02770 -g "$user_name" "/home/$user_name"
    # Check that the password in /etc(shadow is disabled using *, not !,
    # so UsePAM=false works with sshd.
    local s
    s="$(getent shadow "$user_name")"
    s="${s#*:}"
    s="${s%%:*}"
    if test "$s" != '*'; then
      cmd_log usermod -p '*' "$user_name"
    fi

    local user_id service_unit
    user_id="$(id -u "$user_name")"
    service_unit="tliset-sandbox-$user_name.service"
    p_file "service:$service_unit" "\
[Service]
Type=simple
User=$user_name
Slice=user-$user_id.slice

#Restart=on-failure

# Allow to run a user-level systemd instance
ExecStartPre=+chown $user_name -R \
  /sys/fs/cgroup/user.slice/user-$user_id.slice/$service_unit

# X11 including its usage under VNC needs this
ExecStartPre=+mkdir -p -m 01777 /tmp/.X11-unix

ExecStart=systemd
#Environment=SYSTEMD_LOG_LEVEL=debug

# The runtime directory is shared with the host so sshd user session process can
# access it.
RuntimeDirectory=user/$user_id
RuntimeDirectoryMode=0700

Environment=XDG_RUNTIME_DIR=/run/user/$user_id
WorkingDirectory=/home/$user_name
ReadWritePaths=/home/$user_name

NoNewPrivileges=yes
CapabilityBoundingSet=

#SystemCallFilter=~@privileged
SystemCallFilter=~@module @mount @obsolete @raw-io @reboot @reboot
#SystemCallFilter=@debug
SystemCallErrorNumber=EPERM
SystemCallArchitectures=native

RestrictNamespaces=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
#ProtectControlGroups=yes
ProtectSystem=strict
"
  done

}

setup_firewalld() {
  test "$with_firewalld" || return 0
  log "Checking firewalld"
  set --
  if test "$with_nginx"; then
    set -- "$@" http https
  fi
  local service
  for service in "$@"; do
    if ! firewall-cmd -q --permanent --query-service="$service"; then
      cmd_log firewall-cmd --permanent --add-service="$service"
      cmd_log firewall-cmd --add-service="$service"
    fi
  done

  local ports_to_open
  ports_to_open=""
  setup_tormed_service firewalld_ports
  if test "$with_mdns"; then
    ports_to_open="$ports_to_open 5353/udp"
  fi
  local port
  for port in $ports_to_open; do
    if ! firewall-cmd -q --permanent --query-port="$port"; then
      cmd_log firewall-cmd --permanent --add-port="$port"
      cmd_log firewall-cmd --add-port="$port"
    fi
  done

  # Workaround to enable systemd-nspawn containers
  # See https://github.com/systemd/systemd/pull/15412#issuecomment-1142332715
  local reload_firewalld
  reload_firewalld=

  write_file /etc/firewalld/zones/container-vz.xm \
'<?xml version="1.0" encoding="utf-8"?>
<zone target="ACCEPT">
  <service name="dhcp"/>
  <service name="dhcpv6"/>
  <service name="dns"/>
  <service name="llmnr"/>
  <service name="ssh"/>
  <protocol value="icmp"/>
  <protocol value="ipv6-icmp"/>
  <rule priority="32767">
    <reject/>
  </rule>
  <interface name="vz-+"/>
</zone>
'
  test "$file_update" && reload_firewalld=1

  write_file /etc/firewalld/zones/container-ve.xml \
'<?xml version="1.0" encoding="utf-8"?>
<zone target="ACCEPT">
  <service name="dhcp"/>
  <service name="dhcpv6"/>
  <service name="dns"/>
  <service name="llmnr"/>
  <service name="ssh"/>
  <protocol value="icmp"/>
  <protocol value="ipv6-icmp"/>
  <masquerade/>
  <rule priority="32767">
    <reject/>
  </rule>
  <interface name="ve-+"/>
</zone>
'
  test "$file_update" && reload_firewalld=1

  if test "$reload_firewalld"; then
    cmd_log firewall-cmd --reload
  fi
}

setup_containers() {
  if test "${with_gui_container_role}"; then
    write_file /etc/profile.d/50-tliset-container-setup.sh '
# In case the shell is dash set UID.
if test -z "${UID-}"; then
    UID="$(id -ru)"
fi
if test "${UID}" -ne 0 && test -d "/run/user/${UID}"; then
    if test -z "${XDG_RUNTIME_DIR-}"; then
        export XDG_RUNTIME_DIR="/run/user/${UID}"
        if test -z "${WAYLAND_DISPLAY-}" \
            && test -S "${XDG_RUNTIME_DIR}/wayland-0"; then
            export WAYLAND_DISPLAY=wayland-0
        fi
        if test "${WAYLAND_DISPLAY}"; then
          export GDK_BACKEND=wayland
          export QT_QPA_PLATFORM=wayland
        fi
        if ! test -S "${XDG_RUNTIME_DIR}/bus"; then
            export DBUS_SESSION_BUS_ADDRESS="unix:path=${XDG_RUNTIME_DIR}/bus"
            dbus-daemon --fork --session --address="${DBUS_SESSION_BUS_ADDRESS}"
        fi
    fi
    if test -S /run/host/ssh-agent/socket; then
        export SSH_AUTH_SOCK=/run/host/ssh-agent/socket
    fi
fi
if test -s /run/host/timezone; then
  export TZ=:/run/host/timezone
fi
'
  fi
}

setup_test_lms_container() {
  R=
  test "$with_test_lms_container" || return 0

  local container_name ssh_host_port
  container_name=test-lms
  ssh_host_port=3022

  local container_top
  container_top="/var/lib/machines/$container_name"
  if ! test -d "$container_top"; then
    local host_root_ssh_authorized
    host_root_ssh_authorized=/root/.ssh/authorized_keys
    if ! test -s "$host_root_ssh_authorized"; then
      host_root_ssh_authorized=/root/.ssh/authorized_keys2
      if ! test -s "$host_root_ssh_authorized"; then
        err "Failed to determine authorized file for root ssh login keys."
      fi
    fi
    cmd_log rm -rf "$container_top.tmp"
    cmd_log debootstrap --variant=minbase \
      --include=systemd,dbus,openssh-server,iproute2 \
      bullseye "$container_top.tmp"

    printf '%s\n' "$container_name" > "$container_top.tmp/etc/hostname"

    # Copy host root ssh authization
    cmd_log mkdir -p 0700 "$container_top.tmp/root/.ssh"
    cmd_log cp "$host_root_ssh_authorized" \
      "$container_top.tmp/root/.ssh/authorized_keys"

    # Initial initialization, this also shifts uid/gid
    cmd_log systemd-nspawn -D "$container_top.tmp" -n -U /bin/sh -c '
set -x

# Enable networking
systemctl enable systemd-networkd
systemctl enable systemd-resolved
'
    cmd_log mv "$container_top.tmp" "$container_top"
  fi
  note_path "$container_top"

  ensure_dir "/srv/containers"

  # Bind-mount location for /srv
  local container_uid_gid container_uid container_gid
  container_uid_gid="$(stat -c %u:%g "$container_top")"
  container_uid="${container_uid_gid%%:*}"
  container_gid="${container_uid_gid#*:}"
  ensure_dir "/srv/containers/$container_name"
  ensure_dir -u "$container_uid" -g "$container_gid" \
    "/srv/containers/$container_name/home"
  ensure_dir -u "$container_uid" -g "$container_gid" \
    "/srv/containers/$container_name/srv"

  p_file "nspawn:$container_name.nspawn" "\
[Exec]
NoNewPrivileges=yes
Hostname=$container_name

[Files]
Bind=/srv/containers/$container_name/srv:/srv
#Bind=/srv/containers/$container_name/home:/home

[Network]
VirtualEthernet=yes
Port=tcp:$ssh_host_port:22
"
}

setup_nginx_service() {
  test -n "${with_nginx}" || return 0

  local reload_nginx
  reload_nginx=

  local s
  if grep -q '^user www-data;$' /etc/nginx/nginx.conf; then
    log "Patching /etc/nginx/nginx.conf"
    s='s/^\(user www-data\|worker_processes auto\|pid \/run\/nginx.pid\);/#&/g'
    sed -i -e "${s}" /etc/nginx/nginx.conf
    reload_nginx=1
  fi

  local lines
  lines=
  setup_tormed_service nginx_config

  if test "$lines"; then
    p_file "nginx-site:tliset" "$lines"
    test "$file_update" && reload_nginx=1
  fi

  p_ensure_no_file nginx-site:default
  test "$file_update" && reload_nginx=1

  local nginx_cmd
  nginx_cmd="/usr/sbin/nginx"
  nginx_cmd="$nginx_cmd -g '"
  nginx_cmd="$nginx_cmd daemon on;"
  nginx_cmd="$nginx_cmd master_process on;"
  nginx_cmd="$nginx_cmd pid /run/nginx/nginx.pid;"
  nginx_cmd="$nginx_cmd'"

  local unit_fragment
  # shellcheck disable=SC2016
  unit_fragment='
[Service]
PIDFile=/run/nginx/nginx.pid
User=www-data
AmbientCapabilities=CAP_NET_BIND_SERVICE

Restart=on-failure
RestartSec=2s

ExecStartPre=
ExecStart=
ExecStart='"${nginx_cmd}"'
ExecStop=

KillSignal=SIGQUIT
ExecReload=
ExecReload=/bin/kill -s HUP $MAINPID

RuntimeDirectory=nginx
RuntimeDirectoryMode=0700
ReadWritePaths=/var/log/nginx /var/lib/nginx

NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
'

  p_systemd_drop_in nginx.service "${unit_fragment}"
  if test "${file_update}"; then
    add_service_try_restart nginx.service
  elif test "${reload_nginx}"; then
    add_service_reload nginx.service
  fi

  setup_letsencrypt
}

setup_tormed_service() {
  # shellcheck disable=SC2016

  test "$tormed_host" || return 0

  local peer_port1 rpc_port1 peer_port2 rpc_port2
  peer_port1=25602
  peer_port2=51412
  rpc_port1=9091
  rpc_port2=9093

  if test "${1-}" = firewalld_ports; then
    ports_to_open="$ports_to_open $peer_port1/udp $peer_port2/udp"
    ports_to_open="$ports_to_open $peer_port1/tcp $peer_port2/tcp"
  elif test "${1-}" = nginx_config; then
    lines="$lines"'
limit_req_zone $binary_remote_addr zone=tormed:1m rate=5r/s;

upstream transmission {
  server 127.0.0.1:'"$rpc_port1"';
  keepalive 4;
}

upstream transmission2 {
  server 127.0.0.1:'"$rpc_port2"';
  keepalive 4;
}

server {
  server_name '"$tormed_host"';
  listen 80;
  listen [::]:80;

  access_log off;

  location /.well-known/acme-challenge/ {
    alias /run/acme-challenge/;
  }
  location / {
    return 301 https://'"$tormed_host"'$request_uri;
  }
}

server {
  server_name '"$tormed_host"';
  listen 443 ssl http2;
  listen [::]:443 ssl http2;

  ssl_certificate /var/lib/dehydrated/certs/host/fullchain.pem;
  ssl_certificate_key /var/lib/dehydrated/certs/host/privkey.pem;
  ssl_protocols TLSv1.2;

  limit_req zone=tormed burst=25;
  access_log off;

  auth_basic "Restricted";
  auth_basic_user_file /etc/tormed/htpassword/htpassword;

  location / {
    root /usr/lib/tormed/www;
    try_files $uri $uri/ =404;
    index index.html index.htm;
  }

  location /files/ {
    alias /srv/tormed/files/;

    directio 4m;
    output_buffers 1 1m;

    autoindex on;
    autoindex_exact_size off;
    autoindex_localtime on;
    charset utf-8;

    try_files $uri $uri/ =404;
  }

  # Serve static files from the Tranmission web interface itself
  location /transmission/web/ {
    alias /usr/share/transmission/web/;
    index index.html index.htm;
  }

  location /transmission2/web/ {
    alias /usr/share/transmission/web/;
    index index.html index.htm;
  }
  location /transmission/ {
    proxy_pass          http://transmission;
    proxy_http_version  1.1;
    proxy_redirect      off;
    proxy_buffering     off;
    proxy_set_header    Host            $host;
    proxy_set_header    X-Real-IP       $remote_addr;
    proxy_set_header    Connection      "";
    proxy_pass_header   X-Transmission-Session-Id;
  }

  location /transmission2/ {
    proxy_pass          http://transmission2/transmission/;
    proxy_http_version  1.1;
    proxy_redirect      off;
    proxy_buffering     off;
    proxy_set_header    Host            $host;
    proxy_set_header    X-Real-IP       $remote_addr;
    proxy_set_header    Connection      "";
    proxy_pass_header   X-Transmission-Session-Id;
  }

  # /fm - file manager
  location ~ /fm($|/.*) {
    # php.ini must have cgi.fix_pathinfo = 0
    fastcgi_pass unix:/run/tormed/php-fpm/fcgi.socket;
    fastcgi_intercept_errors on;
    include fastcgi_params;
    fastcgi_param SCRIPT_NAME /fm;
    fastcgi_param PATH_INFO $1;
    fastcgi_param SCRIPT_FILENAME /var/lib/tliset/tinyfilemanager/tinyfilemanager.php;

    # Allow for big uploads that take time to process
    fastcgi_read_timeout 1800s;
    fastcgi_send_timeout 1800s;

    # Send request directly to the server
    fastcgi_request_buffering off;
  }
}
'
    return 0
  elif test "${1-}"; then
    err "Unknown subcommand $1"
  fi

  ensure_dir /srv/tormed

  local home_path
  home_path="/srv/tormed/files"
  ensure_user -d "$home_path" tormed-files
  ensure_dir -m 02770 -g tormed-files "$home_path"

  ensure_group_member tormed-files www-data
  if test -n "${file_update}"; then
    # Restart nginx so the process gets the group membership
    add_service_try_restart nginx.service
  fi

  local i
  for i in 1 2; do
    local full_user
    full_user="tormed-service$i"
    home_path="/srv/tormed/service$i"
    ensure_user -d "${home_path}" -G tormed-files "${full_user}"
    ensure_dir -m 0700 -u "${full_user}" -g "${full_user}" "${home_path}"
  done

  ensure_dir /etc/tormed
  ensure_dir -m 0750 -g www-data "/etc/tormed/htpassword"

  ensure_dir /usr/lib/tormed
  ensure_dir /usr/lib/tormed/www

  # shellcheck disable=SC1004,SC2016
  write_file -m 0755 "/var/lib/tliset/tormed-update-password" '#!/bin/sh
set -e -u

err() {
  printf "%s\\n" "$*" >&2
  exit 1
}

if :; then
  test -t 0 -a -t 1 || err "both stdin and stdout must be tty"
  stty_orig="$(stty -g)"
  stty -echo echonl
  IFS= read -r -p "Enter new tormed password: " password || :
  stty "${stty_orig}"
  if test -z "${password}"; then
  err "Password cannot be empty"
  fi
  stty -echo echonl
  IFS= read -r -p "Confirm password: " password2 || :
  stty "${stty_orig}"
  if test "x${password}" != "x${password2}"; then
  err "Passwords mismatches."
  fi
fi

salt="$(dd if=/dev/urandom bs=12 count=1 status=none | base64 -w0 | tr + .)"
test 16 -eq ${#salt} || \
  err "unexpected salt length ${#salt} when 16 was expected"

hash="$(printf %s "$password" | mkpasswd -s -m sha-512 -R 5000 -S "$salt")"
test 118 -eq ${#hash} || \
  err "unexpected password hash length ${#hash} when 118 was expected"

printf "%s:%s\\n" user "$hash" > /etc/tormed/htpassword/htpassword
chmod 644 /etc/tormed/htpassword/htpassword

usermod -p "${hash}" tormed-files
'

  write_file "/usr/lib/tormed/www/index.html" \
'<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<body>
<h3><a href="files/">Files (View-only)</a></h3>
<h3><a href="fm/">File Manager (View/Edit/Upload/Delete)</a></h3>
<h3><a href="transmission/web/">Tranmission web interface</a></h3>
<h3><a href="transmission2/web/">Tranmission web interface 2</a></h3>
</body>
</html>
'

  local i
  for i in 1 2; do
    local full_user peer_port rpc_port
    full_user="tormed-service$i"
    home_path="/srv/tormed/service$i"
    service_name="tormed-service$i"
    eval 'peer_port="$peer_port'"$i"'"'
    eval 'rpc_port="$rpc_port'"$i"'"'
    p_file "service:$service_name.service" "\
[Unit]
After=local-fs.target

[Service]
Type=simple
User=$full_user

Restart=on-failure

Environment=PEER_PORT=$peer_port RPC_PORT=$rpc_port
ExecStart=/var/lib/tliset/tormed-start-transmission

WorkingDirectory=$home_path
ReadWritePaths=$home_path /srv/tormed/files

SystemCallFilter=~@module @mount @obsolete @raw-io @reboot
SystemCallArchitectures=native

RestrictNamespaces=yes
NoNewPrivileges=yes
#PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
"
    if test -n "${file_update}"; then
      add_service_restart "${service_name}.service"
    fi
    add_multi_user_wants "${service_name}.service"
  done

  write_file -m 0755 "/var/lib/tliset/tormed-start-transmission" <<'EOF'
#!/bin/sh

set -e -u

settings_file=settings.json

# Transmission only uses the umask for directories in the config dir.
# It uses the file mode 600 for the state management files and 660/770
# for downloaded files and directories.
umask 002

if test ! -s "$settings_file"; then
  echo "Creating defaults tranmission options in ${settings_file}" >&2

  default_settings='{
  "blocklist-enabled": false,
  "download-dir": "/srv/tormed/files",
  "incomplete-dir": "/srv/tormed/files/incomplete",
  "incomplete-dir-enabled": false,
  "encryption": 1,
  "max-peers-global": 200,
  "pex-enabled": 1,
  "port-forwarding-enabled": false,
  "ratio-limit": 2,
  "ratio-limit-enabled": true,
  "speed-limit-down": 2000,
  "speed-limit-down-enabled": true,
  "speed-limit-up": 500,
  "speed-limit-up-enabled": true,
  "umask": 2
}
'
  ( umask 077 && printf %s "${default_settings}" > "${settings_file}" )
fi

jq_filter='.
| .["peer-port"] = '"$PEER_PORT"'
| .["rpc-authentication-required"] = false
| .["rpc-bind-address"] = "127.0.0.1"
| .["rpc-enabled"] = true
| .["rpc-host-whitelist-enabled"] = false
| .["rpc-port"] = '"$RPC_PORT"'
| .["rpc-username"] = ""
| .["rpc-password"] = ""
| .["rpc-whitelist-enabled"] = false
| .["umask"] = 7
'

settings="$(jq "${jq_filter}" "${settings_file}")"
printf %s "${settings}" > "${settings_file}"

exec /usr/bin/transmission-daemon -f --log-error -g .
#exec /usr/bin/transmission-daemon -f --log-debug -g .
EOF

  local d
  d=/var/lib/tliset/tinyfilemanager
  if { test -e "$d" && ! test -d "$d"; } || test -h "$d"; then
    err "$d exists and is not a directory"
  fi
  if ! test -d "$d"; then
    local version sha256 url
    version=2.5.0
    sha256="847a280ca8e1c31a4a39884da8f301ee77ff1885cec359a996ed3cd1430c8ffd"
    url="https://github.com/prasathmani/tinyfilemanager/archive/refs/tags/$version.tar.gz"
    cmd_log rm -rf "$d.tmp"
    cmd_log mkdir "$d.tmp"
    cmd_log curl -L -o "$d.tmp/archive.tgz" "$url"
    local s
    s="$(shasum -a 256 "$d.tmp/archive.tgz")"
    s="${s%% *}"
    if test "$sha256" != "$s"; then
      err "Failed checksum for $url.${NL}Expected: $sha256${NL}Actual:    $s"
    fi
    cmd_log tar -C "$d.tmp" --strip-components=1 -xf "$d.tmp/archive.tgz"
    cmd_log rm "$d.tmp/archive.tgz"
    cmd_log mv "$d.tmp" "$d"
  fi
  note_path "$d"

  write_file "$d/config.php" '
<?php
$root_path="/srv/tormed/files";
$root_url="/files/";
define("FM_SELF_URL", "https://'"$tormed_host"'/fm/");
$datetime_format = "Y-m-d H:i:s";

# The access is protected using HTTP AUTH
$use_auth = false;
'

  # PHP-FPM does not support logging to stderr and under systemd /proc/self/fd/2
  # is a link to a socket and cannot be openned again. So use a fifo pipe to
  # redirect to stderr.
  local log_fifo pid_file changed_php_fpm_config
  log_fifo=/run/tormed/php-fpm/log.fifo
  pid_file=/run/tormed/php-fpm/main.pid
  changed_php_fpm_config=

  write_file /etc/tormed/php-fpm.conf "\
[global]
error_log = $log_fifo
systemd_interval = 6h
pid = $pid_file

; the single pool
[app]
listen = /run/tormed/php-fpm/fcgi.socket
listen.mode = 0660
pm = ondemand
pm.max_children = 8
pm.max_requests = 1000
catch_workers_output = yes
;; Override values from php.ini
; Allow big uploads
php_value[upload_max_filesize] = 8G
php_value[post_max_size] = 8G
php_value[upload_tmp_dir] = /var/tmp
php_value[max_input_time] = 1800
php_value[max_execution_time] = 500
; Default memory_limit is 128MB
;php_value[memory_limit] = 256M
php_value[cgi.fix_pathinfo] = 0
;php_value[error_log] = syslog
php_value[include_path] = .:/usr/share/php
;php_value[mysqli.default_socket] = /run/mysqld/mysqld.sock
; The cache is enabled by default
; php_value[opcache.enable] = 1

; /var/tmp is private
php_value[session.save_path] = /var/tmp/php-sessions
"

  test "$file_update" && changed_php_fpm_config=1

  write_file -m 0755 "/var/lib/tliset/tormed-php-fpm" '#!/bin/sh
set -e -u

log_fifo='"$log_fifo"'
php_version='"$php_version"'

mkfifo -m 0600 "$log_fifo"

# Open log for reading before we start the php main process and then cat its
# output to stderr. Also open both forreading and writing to avoid the initial
# deadlock.
{ cat >&2 & } <> "$log_fifo"

# /var/tmp is private and must be empty
mkdir -m 0700 /var/tmp/php-sessions

set -- "/usr/sbin/php-fpm$php_version" --nodaemonize
set -- "$@" -c "/etc/php/$php_version/fpm"
set -- "$@" -y "/etc/tormed/php-fpm.conf"

printf "Starting %s\\n" "$*" > "$log_fifo"
exec "$@"
'
  test "$file_update" && changed_php_fpm_config=1

  service_name="tormed-php-fpm"
  p_file "service:$service_name.service" "
[Unit]
After=local-fs.target

[Service]
Type=notify
UMask=0002
User=tormed-files

Restart=on-failure
RestartSec=2s
ExecReload=/bin/kill -USR2 \$MAINPID
PIDFile=$pid_file
RuntimeDirectory=tormed/php-fpm
ReadWritePaths=/srv/tormed/files

ExecStart=/var/lib/tliset/tormed-php-fpm

SystemCallFilter=~@module @mount @obsolete @raw-io @reboot
SystemCallArchitectures=native

RestrictNamespaces=yes
NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
#ProtectSystem=full
"
  test "$file_update" && changed_php_fpm_config=1
  if test "$changed_php_fpm_config"; then
    add_service_restart "$service_name.service"
  fi
  add_multi_user_wants "$service_name.service"
}

setup_game_access_service() {
  test "$with_game_access" || return 0

  local home_path
  home_path="/srv/game/top"
  ensure_group game
  ensure_dir -m 0750 -g game "${home_path%/*}"
  ensure_user -m -d "${home_path}" -g game -s /bin/bash game

  local display
  display=:7

  local service_name=tliset-game-vnc
  p_file "service:${service_name}.service" '
[Service]
Type=simple
User=game

Restart=always
RestartSec=2s

PAMName=login
PIDFile='"${home_path}"'/.vnc/%H'"${display}"'.pid
ExecStartPre=/bin/sh -c "/usr/bin/tigervncserver -kill '"${display}"' > /dev/null 2>&1 || :"
ExecStart=/usr/bin/tigervncserver '"${display}"' -alwaysshared -fg -SecurityType TLSVnc -geometry 1920x1080 -depth 32 -dpi 120
ExecStop=/usr/bin/tigervncserver -kill '"${display}"'

WorkingDirectory='"${home_path}"'
ReadWritePaths='"${home_path}"'

NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
'
  if test -n "${file_update}"; then
    add_service_restart "${service_name}.service"
  fi
  add_multi_user_wants "${service_name}.service"
}

setup_letsencrypt() {
  test "${webserver_certificate_domains}" || return 0

  ensure_dir /var/lib/dehydrated
  ensure_dir -g www-data -m 0770 /var/lib/dehydrated/accounts
  ensure_dir -g www-data -m 0770 /var/lib/dehydrated/certs
  ensure_dir -u www-data -g www-data -m 0755 /var/lib/dehydrated/certs/host
  ensure_dir -g www-data -m 0770 /var/lib/dehydrated/state

  local cert_dir
  cert_dir="/var/lib/dehydrated/certs/host"
  if test ! -s "${cert_dir}/fullchain.pem" ; then
  cmd_log cp /etc/ssl/private/ssl-cert-snakeoil.key \
      "${cert_dir}/privkey.pem"
  cmd_log cp /etc/ssl/certs/ssl-cert-snakeoil.pem \
      "${cert_dir}/fullchain.pem.tmp"
  cmd_log chown www-data:www-data \
      "${cert_dir}/privkey.pem" "${cert_dir}/fullchain.pem.tmp"
  cmd_log mv "${cert_dir}/fullchain.pem.tmp" "${cert_dir}/fullchain.pem"
  fi

  local s
  s='
CA=https://acme-v02.api.letsencrypt.org/directory
# Staging
#CA=https://acme-staging-v02.api.letsencrypt.org/directory
BASEDIR=/var/lib/dehydrated/state
DOMAINS_TXT="/etc/dehydrated/domains.txt"
WELLKNOWN=/run/acme-challenge
CERTDIR="/var/lib/dehydrated/certs"
ACCOUNTDIR="/var/lib/dehydrated/accounts"

# Workaround for a bug in older dehydrated
CURL_OPTS=--http1.1
'
  write_file /etc/dehydrated/config "${s}"
  write_file /etc/dehydrated/domains.txt \
      "${webserver_certificate_domains} > host"

  # shellcheck disable=SC2016
  s='#!/bin/sh
set -e -u

dehydrated --account --accept-terms
dehydrated --cron --force
echo "sending NGINX signal to reload its config" >&2
read -r nginx_pid < /run/nginx/nginx.pid
kill -s HUP "${nginx_pid}"
echo "all OK" >&2
'

  write_file -m 0755 /var/lib/tliset/dehydrated-renew "${s}"

  p_file service:tliset-dehydrated.service '
[Service]
Type=simple
User=www-data

Restart=on-failure

# Try twice a day until success
RestartSec=43200

ExecStart=/var/lib/tliset/dehydrated-renew

RuntimeDirectory=acme-challenge
RuntimeDirectoryMode=0700
ReadWritePaths=/var/lib/dehydrated

NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
ProtectSystem=strict
'

  p_file service:tliset-dehydrated.timer '
[Unit]
After=network-online.target
Wants=network-online.target

[Timer]
Persistent=true
OnCalendar=*-*-7 03:00:00
RandomizedDelaySec=86400
'
  if test -n "${file_update}"; then
    add_service_restart tliset-dehydrated.timer
  fi
  add_multi_user_wants "tliset-dehydrated.timer"

}

run_setup() {
  determine_os

  read_tliset_name

  get_host_options

  if test "${with_dev_container}"; then
    read_tliset_parent_name
  fi

  begin_tliset

  start_generator_write

  setup_log
  setup_network

  if test -z "${under_qubes}"; then
    setup_packages
  fi

  # Setup sshd before we try to setup sshd packages to have sshd_config ready
  # before apt install and starts sshd.
  setup_sshd

  setup_kernel_parameters
  setup_initramfs_and_grub
  setup_filesystems
  setup_users
  setup_services
  setup_firewalld

  finish_generator_write

  end_tliset

  if test "${initialize_tliset_name}"; then
    ! test -e /etc/tliset.name || err "/etc/tliset.name must not exist"
    log "Writing ${NAME} to /etc/tliset.name"
    printf '%s\n' "${NAME}" > /etc/tliset.name
  fi

  log "Done."
}

for var_and_value in "$@"; do
  # check for name=value pattern and call readonly to initialize the
  # variable.
  variable="${var_and_value%%=*}"
  test "${variable}" != "${var_and_value}" || break
  case "${variable}" in
  "" | *[^a-zA-Z0-9_]* | [0-9]* )
    err "invalid variable name for the the main script: ${variable}"
    ;;
  esac
  readonly "${var_and_value}"
done

run_setup
