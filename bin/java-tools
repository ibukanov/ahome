#!/usr/bin/perl

use strict;

use igor::Base;

if (!$ENV{JAVA_HOME}) {
	print STDERR "$0: JAVA_HOME is not defined\n";
	exit(1);
}

my $guess_dest = 1;

my $PATH_SEPARATOR = ':';
if ($^O eq 'MSWin32') { $PATH_SEPARATOR = ';'; }

my $RES_LIST_NAME = "res.lst";
my $RES_DIR_NAME = "resources";

sub trim_str($)
{
	my $str = shift;
	$str =~ s/^\s+//;
	$str =~ s/\s+$//;
	return $str;
}

sub remove_java_comments($)
{
	$_[0] =~ s(//[^\n]*)()g; # remove // comments
	$_[0] =~ s(/\*.*?\*/)()gs; # remove /* ... */ comments
}

sub get_package_path($$)
{
	use File::Basename;
	my $package = $_[0];
	my $path = $_[1];
	my $relpath = basename($path);
	$package =~ s(\.)(/)g;
	$relpath = "$package/$relpath" if (length($package) != 0);
	return $relpath;
}

sub create_path_dirs($)
{
	use File::Basename;
	use File::Path;
	my $path = $_[0];
	mkpath(dirname($path));
}

sub extract_package_name($)
{
	my $path = $_[0];
	my $package = "";
	my $body;
	if (!read_file($path, $body)) { report_errors(); }
	else {
		remove_java_comments($body);
		$package = $1 if ($body =~ m/\s*package\s+([a-zA-Z0-9._]+)\s*;/s);
	}
	return $package;
}

sub list_to_str(@)
{
	return (@_) ? "('" . join("', '", @_) . "')" : "()";
}

sub path_to_list($)
{
	my $path = $_[0];
	
	use File::Basename;    
	use File::Spec;    

	my $DOT = File::Spec->curdir;
	$path = File::Spec->canonpath($path);
	my @list = ();
	while ($path and $path ne $DOT) {
		my $base;
		($base, $path) = fileparse($path);
		if (!$base) { 
			push(@list, $path);
			last;
		}
		if ($base ne $DOT) {
			push(@list, $base);
		}
		$path = File::Spec->canonpath($path); 
	}
	return reverse(@list);
}

sub get_base_name($)
{
	my $path = $_[0];
	use File::Basename;
	return basename($path); 
}

sub list_to_path(@)
{
	use File::Spec;    
	return (@_) ? File::Spec->catdir(@_) : File::Spec->curdir;	
}

sub remove_path_list_down_up(@)
{
	use File::Spec;    

	my $UP = File::Spec->updir;
	my $ROOT = File::Spec->rootdir;
	my @list;
	
	for my $name (@_) {
		if ($name eq $UP and @list and $list[-1] ne $UP) {
			pop(@list) unless (@list == 1 and $list[0] eq $ROOT);
		}
		else {
			push(@list, $name);
		}
	}
	return @list;
}

sub dir_list_parent(@)
{
	use File::Spec;    

	my $UP = File::Spec->updir;
	my $ROOT = File::Spec->rootdir;

	return $UP unless (@_);
	return @_ if (@_ == 1 and $_[0] eq $ROOT);

	if ($_[-1] eq $UP) { push(@_, $UP); }
	else { pop(@_); }

	return @_;
}

sub path_parent($)
{
	my $path = $_[0];
	return list_to_path(dir_list_parent(path_to_list($path)));
}

sub construct_java_source_root($$)
{
	my $package = $_[0];
	my $first_source = $_[1];

	use File::Spec;    

	my @dir = path_to_list($first_source);
	if (@dir) {
		pop(@dir); # drop file name
		if ($package ne "") {
			my $UP = File::Spec->updir;
			my @names = split(/\./, $package);
			for (my $i = @names; $i-- != 0;) {
				push(@dir, $UP);
			}
		}
	}
	@dir = remove_path_list_down_up(@dir);
	return @dir;	
}

sub extract_res_list($)
{
	my $array = $_[0];
	my @resfiles;
	for (my $i = 0; $i != @$array; ) {
		my $file = $array->[$i];
		my $name = get_base_name($file);
		if ($name eq $RES_LIST_NAME || $name eq $RES_DIR_NAME) { 
			push @resfiles, $file;
			splice @$array, $i, 1;
		}
		else { ++$i; }
	}
	return @resfiles;
}

sub extract_java_source_root(@)
{
	use File::Spec; 
	for my $i (@_) {
		if ($i =~ m /\.java/ and -f $i) {
			my $package = extract_package_name($i);
			return construct_java_source_root($package, $i);
		}
	}
	for my $i (@_) {
		if ($i =~ m((^|[/\\])$RES_LIST_NAME) and -f $i) {
			use FileHandle;
			my $fh = new FileHandle $i, "r";
    			if (defined $fh) {
        			my $package = trim_str($fh->getline);
				undef $fh;
				return construct_java_source_root($package, $i);
			}
		}
	}
	for my $i (@_) {
		if ($i =~ m((^|[/\\])$RES_DIR_NAME) and -d $i) {
			my $package = get_package_for_res_dir($i);
			if (defined($package)) {
				return construct_java_source_root($package, $i);
			}
		}
	}
	die "Can not find source root"; 
}

my %cached_res_packages = ();

sub get_package_for_res_dir($) {
	my $res_dir = $_[0];
	my $package = $cached_res_packages{$res_dir};
	if (!defined($package)) {
		use File::Basename;
		use File::Spec;
		my $parent = dirname($res_dir);
		my $pattern = File::Spec->catfile($parent, "*.java");
		my @java_sources = glob($pattern);
		if (scalar(@java_sources)) {
			my $java_file = $java_sources[0];
			$package = extract_package_name($java_file);
			if (defined($package)) {
				$cached_res_packages{$res_dir} = $package;
			}
			
		}
	}
	return $package;
}

sub extract_source_root_from_res_dir($) {
	my $res_dir = $_[0];
	my $package = get_package_for_res_dir($res_dir);
	return construct_java_source_root($package, $res_dir);
}

sub list_to_classpath(@)
{
	return join($PATH_SEPARATOR, @_);
}

sub java_root_to_class_path($)
{
	my @list = ();
	my $java_root = $_[0];
	use File::Spec;
	my $lib_dir = File::Spec->catdir($java_root, "lib");
	my $main_jar = File::Spec->catfile($lib_dir, "classes.zip");
	if (-r $main_jar) {
		# jdk 1.1
		push @list, $main_jar;
	}
	else {
		$main_jar = File::Spec->catfile($lib_dir, "rt.jar");
		if (! -r $main_jar) {
			$lib_dir = File::Spec->catdir($java_root, "jre", "lib");
			$main_jar = File::Spec->catfile($lib_dir, "rt.jar");
		}
		
		if (-r $main_jar) {
			push @list, $main_jar;
			my $lib_glob = File::Spec->catfile($lib_dir, "*.jar");
			my @std_lib = grep { $_ ne $main_jar; } glob($lib_glob);
			push @list, (@std_lib);
			
			my $ext_glob = File::Spec->catfile($lib_dir, "ext", "*.jar");
			push @list, glob($ext_glob);
		}
	}
	return @list;
}

sub get_sys_class_path()
{
	my @sys_path = ();
	my $dir = $ENV{JAVA_HOME};
	@sys_path = java_root_to_class_path($dir);
	my @add_libs = glob("/qset/java/lib/*.jar");
	my $sys_classes = list_to_classpath(@sys_path, @add_libs);
	return $sys_classes;
}

sub destination_to_path($@)
{
	my $destination = shift;

	use File::Spec;    

	if (!File::Spec->file_name_is_absolute($destination) && $guess_dest) {
		my @source_root = @_;
		my $from_source = list_to_path(@source_root, path_to_list($destination));
		for (my $i = 0; $i != 10 and ! -d $from_source; ++$i)
		{
			@source_root = dir_list_parent(@source_root);
			$from_source = list_to_path(@source_root, path_to_list($destination));
		}
		$destination = $from_source;
	}
	return $destination;
}

sub get_extra_jars(@) 
{
	my $jardir = destination_to_path("jarlib", @_);
	my @jars = ();
	if (-d $jardir) {
		my @list = glob(File::Spec->catfile($jardir, "*"));
	    	map { 
		    my $name = $_; 
		    if (-d $name or $name =~ m/\.jar$/i) {
		    	push @jars, $name;
		    }
		} @list;
	}
	return list_to_classpath(@jars);
}


sub make_classpath(@)
{
	return list_to_classpath(@_, $ENV{CLASSPATH});
}

sub copy_file_to_dir($$$)
{
	my $source = $_[0];
	my $dir   = $_[1];
	my $assume_same_if_same_time_staps = $_[2];
	

	use File::Basename;
	use File::Spec;
	use File::stat;

	my $destination = File::Spec->catfile($dir, basename($source));
	my $st = stat($source);
	if (!$st) {
		warn "Copy source $source does not exist: $!";
	}
	else {
		my $same_file = 0;
		my $dest_st = lstat($destination);
		if ($dest_st) {
			if ( -l _ ) { unlink($destination); }
			elsif ($assume_same_if_same_time_staps) {
				if ($dest_st->mtime == $st->mtime) { 
					$same_file = 1;
				}
			}
			if (!$same_file) {
				use File::Compare;
				if (0 == compare($source, $destination)) {
					$same_file = 1;
				}
			}
		}
		if (!$same_file) {
			use File::Copy;
			if (!copy($source, $destination)) {
				warn "Can not copy $source to $destination: $!";
			}
			else {
				my $now = time;
				utime $now, $st->mtime, $destination;
			}			
		}
	}
}


sub copy_res_files($$)
{
	my $destination = $_[0];
	my $list        = $_[1];
	foreach my $file (@$list) {
		if (get_base_name($file) eq $RES_LIST_NAME) {
			copy_res_from_list_in_file($destination, $file);
		}else {
			copy_res_from_dir($destination, $file);
		}
	}
}
		
sub copy_res_from_list_in_file($$)
{
	my @destination  = path_to_list($_[0]);
	my $file         = $_[1];
	use FileHandle;
	my $fh = new FileHandle($file, "r");
	if (defined $fh) {
        	my $package = trim_str($fh->getline);
		my @patterns = $fh->getlines;
	    	undef $fh;

		my @res_dir = path_to_list($file);
		pop @res_dir;

		my $full_pattern = "";
		foreach my $pattern (@patterns) {
			my $s = trim_str($pattern);
			if ($s ne "") {
				$full_pattern .= " " if ($full_pattern ne "");
				$full_pattern .= list_to_path(@res_dir, $s);
			}
		}
		my @res_dir_files = glob($full_pattern);

		my $package_dest_dir 
			= list_to_path(@destination, split(/\./, $package));

		if ( ! -d $package_dest_dir ) {
			use File::Path;
			mkpath($package_dest_dir);
		}
		map { copy_file_to_dir($_, $package_dest_dir, 1); } 
			@res_dir_files;
	}

}

sub copy_res_from_dir($$)
{
	use File::Basename;
	my @destination = path_to_list($_[0]);
	my $res_dir     = $_[1];
	my $res_dir_name = basename($res_dir);

        my $package = get_package_for_res_dir($res_dir);
	my @res_dir_files = glob(File::Spec->catfile($res_dir, "*"));
	
	my $package_dest_dir = list_to_path
		(@destination, split(/\./, $package), $res_dir_name);

	if ( ! -d $package_dest_dir ) {
		use File::Path;
		mkpath($package_dest_dir);
	}
	map { copy_file_to_dir($_, $package_dest_dir, 1) if (-f $_); }
		@res_dir_files;
}

sub exec_java_compiler($$$)
{
	use File::Spec;    
	my $compiler     = $_[0];
	my $destination  = $_[1];
	my $args         = $_[2];

	my @source_root = extract_java_source_root(@$args);

	my @res_files = extract_res_list($args);
	my $source_root = list_to_path(@source_root);
	my @command;
	$destination = destination_to_path($destination, @source_root);

	if (@res_files) {
		copy_res_files($destination, \@res_files);
	}
	
	if (!scalar(@$args)) { return; }
	
	my $destination_libs = get_extra_jars(@source_root);
	
	if ($compiler->[0] eq "jikes") {
		push @command, @$compiler;
		push @command, "-sourcepath", $source_root;
		my $classes = list_to_classpath
			($destination, $destination_libs, $ENV{CLASSPATH});
		my $sys_classes = get_sys_class_path();
		if ($sys_classes) {
			push @command, "-bootclasspath", $sys_classes;
		}
		push @command, "-classpath", $classes;
	}
	else {
		# ALERT: fix later
		my $classes = make_classpath($source_root, $destination, $destination_libs);
		$ENV{CLASSPATH} = make_classpath($source_root);
		@command = (@$compiler);
	}
	if (! -d $destination) {
		print(STDERR <<";;");
Class compilation destination is not directory or does not exist:
$destination
;;
		exit(1);
	}
	push(@command, "-d", $destination);
	exec(@command, @$args);
}		

sub split_to_java_options_and_args(@)
{
	my @options = ();
	my @args = ();
	while (@_) {
		my $arg = shift;
		if ($arg =~ m/^-/) {  
			push @options, $arg;
			if ($arg eq '-classpath' and @_) {
				push(@options, shift);
			}
		}
		else { 
			@args = ($arg, @_);
			last; 
		}
	}
	return { options => \@options, args => \@args };
}

sub exec_java_interpreter($$$)
{
	my $command      = $_[0];
	my $destination  = $_[1];
	my $args         = $_[2];
	
	my $ret = split_to_java_options_and_args(@$args);
	my $options = $ret->{options};
	$args = $ret->{args};
	if (@$args != 0 && $args->[0] =~ m/\.java$/) {
		my $source = shift @$args;
	        my $package = extract_package_name($source);
		my @source_root = construct_java_source_root($package, $source);
		my $source_root = list_to_path(@source_root);
		my $full_class = $source;
		$full_class =~ s{.*/}{};
		$full_class =~ s{\.java$}{$1};		 
		$full_class = "$package.$full_class" if ($package);

		my $destination_path = destination_to_path($destination, @source_root);

		my $destination_libs = get_extra_jars(@source_root);

		$ENV{CLASSPATH}  = list_to_classpath($destination_path, $destination_libs, $ENV{CLASSPATH});
#		$ENV{CLASSPATH}  = list_to_classpath($destination_path, $source_root, $destination_libs, $ENV{CLASSPATH});
		exec(@$command, @$options, $full_class, @$args);
	}
	else {
		exec(@$command, @$options, @$args);
	}
}

my $destination = "classes";
#my @compiler = qw(javac);
#my @compiler = qw(jikes +D +F +T4 -target 1.1 -source 1.1);
my @compiler = qw(jikes +D +F +T4);

my @java_command = qw(java);
my @jdb_command = qw(jdb);

if ($ARGV[0] eq "-d") {
  shift @ARGV; 
  $destination = shift @ARGV;
  $guess_dest = 0;
} 
 
if ($0 eq "jc" or $0 =~ m(/jc$)) {
	exec_java_compiler(\@compiler, $destination, \@ARGV);
}
elsif ($0 eq "rj" or $0 =~ m(/rj$)) {
	exec_java_interpreter(\@java_command, $destination, \@ARGV);
}
elsif ($0 eq "rjdb" or $0 =~ m(/rjdb$)) {
	exec_java_interpreter(\@jdb_command, $destination, \@ARGV);
}
