#!/bin/bash

set -e -u

log() {
    printf "%s\n" "$*" 1>&2
}

err() {
    log "$@"
    log "stack: ${FUNCNAME[*]}"
    exit 1
}

usage_err() {
    log "Usage error: $*"
    log "Try $0 -h for details"
    exit 1
}

trap exit_cleanup EXIT
tmp_dir=
exit_cleanup() {
    if [[ $tmp_dir ]]; then
        rm -rf "$tmp_dir"
    fi 
}

# Do not use printf %q as that may use escapes that are not supported
# by the remote shell. Rather escape argument using single quotas with
# with each single quote in arg replaced by '"'"'
escape_for_shell() {
    local arg="$1" escaped= before_quote
    while : ; do
	before_quote="${arg%%\'*}"
	[[ $arg != "$before_quote" ]] || break
	escaped="$escaped$before_quote'\"'\"'"
	arg="${arg#*\'}"
    done
    printf %s "'$escaped$arg'"
}

main() {
    local -r transfer_dir_subpath=".cache/docker-image-transfer"
    local -r local_transfer_dir="$HOME/$transfer_dir_subpath"
    local -r remote_transfer_dir="$transfer_dir_subpath"
    mkdir -p "$local_transfer_dir"

    local dir="${image//\//%}"

    cd "$local_transfer_dir"

    local id
    id="$(ssh "$source_host" "docker inspect -f '{{.Id}}' $(escape_for_shell "$image")")"
    [[ $id == sha256:* ]] || err "image ID must start with sha256: prefix,  was ${#id}($id)"
    local old_id=""
    if [[ -f "$dir/id" ]]; then
	read -r old_id < $dir/id || :
    fi
    if [[ $id == "$old_id" ]]; then
	log "using already saved image"
    else
	log "saving image from $source_host"
	tmp_dir="tmp.$(date +%s.%N)"
	mkdir "$tmp_dir"
	ssh "$source_host" "docker save $(escape_for_shell "$id")" \
	    | gzip --rsyncable > "$tmp_dir/image.tar.gz"
	printf %s "$id" > "$tmp_dir/id"
	if [[ -d $dir ]]; then
            rm -rf "$dir"
	fi
	mv "$tmp_dir" "$dir"
    fi
    
    log "sending image to $destination_host"
    local destination_path="$remote_transfer_dir/$dir.tar.gz"

    ssh "$destination_host" "mkdir -p $(escape_for_shell "$remote_transfer_dir")"
    rsync --ignore-times -Pv "$dir/image.tar.gz" "$destination_host:$destination_path"
    
    log "loading image on $destination_host"

    ssh_script="\
set -e -u
docker load -i $(escape_for_shell "$destination_path")
docker tag $(escape_for_shell "$id") $(escape_for_shell "$image")
"
    ssh "$destination_host" "$ssh_script"
}

show_usage=
source_host=

while getopts :hs: opt; do
    case $opt in
	h ) show_usage="1" ;;
	s ) source_host="$OPTARG" ;;
	: ) usage_err "option -$OPTARG requires an argument";;
	* ) usage_err "invalid option -$OPTARG";;
    esac
done
shift $(($OPTIND - 1))

if [[ $show_usage ]]; then
    printf %s "\
Usage: $0 [OPTION]... docker-image-name destination-host
Transfer the named docker image from source-host to destination using ssh.

Available options:
    -h       show this help end exit
    -s host  get image from docker running on HOST
"
    exit 0
fi

[[ $# -le 2 ]] || usage_err "unexpected positional arguments"
[[ $# -ge 2 ]] || usage_err "both docker-image-name destination-host must be given"

image="$1"
destination_host="$2"
echo "$source_host"
main
